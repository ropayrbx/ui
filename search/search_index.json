{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Build your best UI. Fusion is a modern reactive UI library, built specifically for Roblox and Luau . Build your UI with a declarative syntax that's easy to read and write. Plug in live data with simple, flexible, truly reactive state management. Deliver a fast, smooth experience to everyone - on mobile, console, PC or in VR. Get started Download latest Declarative UI syntax Fusion provides a natural, easy to read syntax, so you can focus on what your UI should look like, without worrying about the implementation. Focus on the properties and children in your UI, not verbose APIs. return New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , [ Children ] = New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ) AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" , [ OnEvent \"Activated\" ] = function () print ( \"Clicked!\" ) end } } Reactive state management Fluidly write all your calculations, and they'll be automatically run as your variables change. Fusion accelerates and optimises all of your computations for you. local numCoins = State ( 10 ) local doubleCoins = Computed ( function () return numCoins : get () * 2 end ) local coinsMessage = Computed ( function () return \"You have \" .. numCoins : get () .. \" coins.\" end ) return New \"TextLabel\" { Text = coinsMessage } Animate everything Bring your UI to life with the simplest, most universal animation tools of any Roblox library. Access tweens and springs with one line of code. Animate anything instantly, no refactoring or performance tricks required. local playerCount = State ( 100 ) local position = State ( UDim2 . new ( 0 , 0 , 0 , 0 )) local smoothCount = Tween ( playerCount , TweenInfo . new ( 0.5 )) return New \"TextLabel\" { Position = Spring ( position , 25 , 0.2 ), Text = Computed ( function () return \"Players online: \" .. math.floor ( smoothCount : get ()) end ) } Fusion is built with performance in mind, from idea to implementation. From top-end desktop PCs to budget phones from years ago, Fusion delivers an exceptionally light, fluid experience as standard. Build your most beautiful, bold, animated interfaces with confidence - Fusion scales to high-refresh-rate devices and VR effortlessly. Get up and running with Fusion in minutes. Downloading and importing Fusion into Studio is quick, easy and 100% free. The Fusion starter tutorials are aimed at a wide range of creators, from seasoned UI developers to novice scripters.","title":"Home"},{"location":"api-reference/","text":"API Reference \u00b6 Fusion is a modern reactive UI library, designed and built for Roblox and Luau . Here, you can find documentation for every public API exposed by the Fusion module. Navigation \u00b6 Using the sidebar on the left, you can find API members grouped by category. Alternatively, you can search for APIs using the search box at the top of the page. Type Information \u00b6 On many API pages, you'll see type annotations describing the API member. For example: function New ( className : string ): ( props : {[ string | Symbol ]: any }) -> Instance While these type annotations are designed to be Luau-like, they are ultimately psuedocode included as a developer aid. For fully accurate and syntactically valid type information, please refer to the source code directly. Commonly Used \u00b6 Jump directly to the documentation for some common APIs: Instances \u00b6 New State Management \u00b6 State Computed ComputedPairs Animation \u00b6 Tween Spring","title":"Home"},{"location":"api-reference/#api-reference","text":"Fusion is a modern reactive UI library, designed and built for Roblox and Luau . Here, you can find documentation for every public API exposed by the Fusion module.","title":"API Reference"},{"location":"api-reference/#navigation","text":"Using the sidebar on the left, you can find API members grouped by category. Alternatively, you can search for APIs using the search box at the top of the page.","title":"Navigation"},{"location":"api-reference/#type-information","text":"On many API pages, you'll see type annotations describing the API member. For example: function New ( className : string ): ( props : {[ string | Symbol ]: any }) -> Instance While these type annotations are designed to be Luau-like, they are ultimately psuedocode included as a developer aid. For fully accurate and syntactically valid type information, please refer to the source code directly.","title":"Type Information"},{"location":"api-reference/#commonly-used","text":"Jump directly to the documentation for some common APIs:","title":"Commonly Used"},{"location":"api-reference/#instances","text":"New","title":"Instances"},{"location":"api-reference/#state-management","text":"State Computed ComputedPairs","title":"State Management"},{"location":"api-reference/#animation","text":"Tween Spring","title":"Animation"},{"location":"api-reference/errors-and-messages/","text":"If your code isn't working properly, or if Fusion is malfunctioning, you may see some errors being printed to the output. Each message comes with a unique ID at the end. On this page, you can learn more about any error messages you're receiving. cannotAssignProperty \u00b6 The class type 'Foo' has no assignable property 'Bar'. This message shows if you try to assign a non-existent or locked property using the New function: local folder = New \"Folder\" { DataCost = 12345 , ThisPropertyDoesntExist = \"Example\" } Tip Different scripts may have different privileges - for example, plugins will be allowed more privileges than in-game scripts. Make sure you have the necessary privileges to assign to your properties! cannotConnectChange \u00b6 The Frame class doesn't have a property called 'Foo'. This message shows if you try to connect a handler to a non-existent property change event when using the New function: local textBox = New \"TextBox\" { [ OnChange \"ThisPropertyDoesntExist\" ] = function () ... end ) } cannotConnectEvent \u00b6 The Frame class doesn't have an event called 'Foo'. This message shows if you try to connect a handler to a non-existent event when using the New function: local button = New \"TextButton\" { [ OnEvent \"ThisEventDoesntExist\" ] = function () ... end ) } cannotCreateClass \u00b6 Can't create a new instance of class 'Foo'. This message shows when using the New function with an invalid class type: local instance = New \"ThisClassTypeIsInvalid\" { ... } computedCallbackError \u00b6 Computed callback error: attempt to index a nil value This message shows when the callback of a computed object encounters an error: local example = Computed ( function () local badMath = 2 + \"fish\" end ) invalidSpringDamping \u00b6 The damping ratio for a spring must be >= 0. (damping was -0.50) This message shows if you try to provide a damping ratio to a spring which is less than 0: local speed = 10 local damping = - 12345 local spring = Spring ( state , speed , damping ) Damping ratio must always be between 0 and infinity for a spring to be physically simulatable. invalidSpringSpeed \u00b6 The speed of a spring must be >= 0. (speed was -2.00) This message shows if you try to provide a speed to a spring which is less than 0: local speed = - 12345 local spring = Spring ( state , speed ) Since a speed of 0 is equivalent to a spring that doesn't move, any slower speed is not simulatable or physically sensible. mistypedSpringDamping \u00b6 The damping ratio for a spring must be a number. (got a boolean) This message shows if you try to provide a damping ratio to a spring which isn't a number: local speed = 10 local damping = true local spring = Spring ( state , speed , damping ) mistypedSpringSpeed \u00b6 The speed of a spring must be a number. (got a boolean) This message shows if you try to provide a speed to a spring which isn't a number: local speed = true local spring = Spring ( state , speed ) mistypedTweenInfo \u00b6 The tween info of a tween must be a TweenInfo. (got a boolean) This message shows if you try to provide a tween info to a tween which isn't a TweenInfo: local tweenInfo = true local tween = Tween ( state , tweenInfo ) pairsDestructorError \u00b6 ComputedPairs destructor error: attempt to index a nil value This message shows when the destructor callback of a ComputedPairs object encounters an error: local example = ComputedPairs ( data , processor , function ( value ) local badMath = 2 + \"fish\" end ) pairsProcessorError \u00b6 ComputedPairs callback error: attempt to index a nil value This message shows when the processor callback of a ComputedPairs object encounters an error: local example = ComputedPairs ( data , function ( key , value ) local badMath = 2 + \"fish\" end ) springTypeMismatch \u00b6 The type 'number' doesn't match the spring's type 'Color3'. Some methods on spring objects require incoming values to match the types previously being used on the spring. This message shows when an incoming value doesn't have the same type as values used previously on the spring: local colour = State ( Color3 . new ( 1 , 0 , 0 )) local colourSpring = Spring ( colour ) colourSpring : addVelocity ( Vector2 . new ( 2 , 3 )) strictReadError \u00b6 'Foo' is not a valid member of 'Bar'. In Fusion, some tables may have strict reading rules. This is typically used on public APIs as a defense against typos. This message shows when trying to read a non-existent member of these tables. unknownMessage \u00b6 Unknown error: attempt to index a nil value If you see this message, it's almost certainly an internal bug, so make sure to get in contact so the issue can be fixed. When Fusion code attempts to log a message, warning or error, it needs to provide an ID. This ID is used to show the correct message, and serves as a simple, memorable identifier if you need to look up the message later. However, if that code provides an invalid ID, then the message will be replaced with this one. unrecognisedChildType \u00b6 'number' type children aren't accepted as children in `New`. This message shows when attempting to pass something as a child which isn't an instance, table of instances, or state object containing an instance (when using the New function): local instance = New \"Folder\" { [ Children ] = { 1 , 2 , 3 , 4 , 5 , { true , false }, State ( Enum . Material . Grass ) } } Note Note that state objects are allowed to store nil to represent the absence of an instance, as an exception to these rules. unrecognisedPropertyKey \u00b6 'number' keys aren't accepted in the property table of `New`. When you create an instance in Fusion using New , you can pass in a 'property table' containing properties, children, event and property change handlers, etc. This table is only expected to contain keys of two types: string keys, e.g. Name = \"Example\" a few symbol keys, e.g. [ OnEvent \"Foo\" ] = ... This message shows if Fusion finds a key of a different type, or if the key isn't one of the few symbol keys used in New: local folder = New \"Folder\" { [ Vector3 . new ()] = \"Example\" , \"This\" , \"Shouldn't\" , \"Be\" , \"Here\" }","title":"Errors & Messages"},{"location":"api-reference/errors-and-messages/#cannotassignproperty","text":"The class type 'Foo' has no assignable property 'Bar'. This message shows if you try to assign a non-existent or locked property using the New function: local folder = New \"Folder\" { DataCost = 12345 , ThisPropertyDoesntExist = \"Example\" } Tip Different scripts may have different privileges - for example, plugins will be allowed more privileges than in-game scripts. Make sure you have the necessary privileges to assign to your properties!","title":"cannotAssignProperty"},{"location":"api-reference/errors-and-messages/#cannotconnectchange","text":"The Frame class doesn't have a property called 'Foo'. This message shows if you try to connect a handler to a non-existent property change event when using the New function: local textBox = New \"TextBox\" { [ OnChange \"ThisPropertyDoesntExist\" ] = function () ... end ) }","title":"cannotConnectChange"},{"location":"api-reference/errors-and-messages/#cannotconnectevent","text":"The Frame class doesn't have an event called 'Foo'. This message shows if you try to connect a handler to a non-existent event when using the New function: local button = New \"TextButton\" { [ OnEvent \"ThisEventDoesntExist\" ] = function () ... end ) }","title":"cannotConnectEvent"},{"location":"api-reference/errors-and-messages/#cannotcreateclass","text":"Can't create a new instance of class 'Foo'. This message shows when using the New function with an invalid class type: local instance = New \"ThisClassTypeIsInvalid\" { ... }","title":"cannotCreateClass"},{"location":"api-reference/errors-and-messages/#computedcallbackerror","text":"Computed callback error: attempt to index a nil value This message shows when the callback of a computed object encounters an error: local example = Computed ( function () local badMath = 2 + \"fish\" end )","title":"computedCallbackError"},{"location":"api-reference/errors-and-messages/#invalidspringdamping","text":"The damping ratio for a spring must be >= 0. (damping was -0.50) This message shows if you try to provide a damping ratio to a spring which is less than 0: local speed = 10 local damping = - 12345 local spring = Spring ( state , speed , damping ) Damping ratio must always be between 0 and infinity for a spring to be physically simulatable.","title":"invalidSpringDamping"},{"location":"api-reference/errors-and-messages/#invalidspringspeed","text":"The speed of a spring must be >= 0. (speed was -2.00) This message shows if you try to provide a speed to a spring which is less than 0: local speed = - 12345 local spring = Spring ( state , speed ) Since a speed of 0 is equivalent to a spring that doesn't move, any slower speed is not simulatable or physically sensible.","title":"invalidSpringSpeed"},{"location":"api-reference/errors-and-messages/#mistypedspringdamping","text":"The damping ratio for a spring must be a number. (got a boolean) This message shows if you try to provide a damping ratio to a spring which isn't a number: local speed = 10 local damping = true local spring = Spring ( state , speed , damping )","title":"mistypedSpringDamping"},{"location":"api-reference/errors-and-messages/#mistypedspringspeed","text":"The speed of a spring must be a number. (got a boolean) This message shows if you try to provide a speed to a spring which isn't a number: local speed = true local spring = Spring ( state , speed )","title":"mistypedSpringSpeed"},{"location":"api-reference/errors-and-messages/#mistypedtweeninfo","text":"The tween info of a tween must be a TweenInfo. (got a boolean) This message shows if you try to provide a tween info to a tween which isn't a TweenInfo: local tweenInfo = true local tween = Tween ( state , tweenInfo )","title":"mistypedTweenInfo"},{"location":"api-reference/errors-and-messages/#pairsdestructorerror","text":"ComputedPairs destructor error: attempt to index a nil value This message shows when the destructor callback of a ComputedPairs object encounters an error: local example = ComputedPairs ( data , processor , function ( value ) local badMath = 2 + \"fish\" end )","title":"pairsDestructorError"},{"location":"api-reference/errors-and-messages/#pairsprocessorerror","text":"ComputedPairs callback error: attempt to index a nil value This message shows when the processor callback of a ComputedPairs object encounters an error: local example = ComputedPairs ( data , function ( key , value ) local badMath = 2 + \"fish\" end )","title":"pairsProcessorError"},{"location":"api-reference/errors-and-messages/#springtypemismatch","text":"The type 'number' doesn't match the spring's type 'Color3'. Some methods on spring objects require incoming values to match the types previously being used on the spring. This message shows when an incoming value doesn't have the same type as values used previously on the spring: local colour = State ( Color3 . new ( 1 , 0 , 0 )) local colourSpring = Spring ( colour ) colourSpring : addVelocity ( Vector2 . new ( 2 , 3 ))","title":"springTypeMismatch"},{"location":"api-reference/errors-and-messages/#strictreaderror","text":"'Foo' is not a valid member of 'Bar'. In Fusion, some tables may have strict reading rules. This is typically used on public APIs as a defense against typos. This message shows when trying to read a non-existent member of these tables.","title":"strictReadError"},{"location":"api-reference/errors-and-messages/#unknownmessage","text":"Unknown error: attempt to index a nil value If you see this message, it's almost certainly an internal bug, so make sure to get in contact so the issue can be fixed. When Fusion code attempts to log a message, warning or error, it needs to provide an ID. This ID is used to show the correct message, and serves as a simple, memorable identifier if you need to look up the message later. However, if that code provides an invalid ID, then the message will be replaced with this one.","title":"unknownMessage"},{"location":"api-reference/errors-and-messages/#unrecognisedchildtype","text":"'number' type children aren't accepted as children in `New`. This message shows when attempting to pass something as a child which isn't an instance, table of instances, or state object containing an instance (when using the New function): local instance = New \"Folder\" { [ Children ] = { 1 , 2 , 3 , 4 , 5 , { true , false }, State ( Enum . Material . Grass ) } } Note Note that state objects are allowed to store nil to represent the absence of an instance, as an exception to these rules.","title":"unrecognisedChildType"},{"location":"api-reference/errors-and-messages/#unrecognisedpropertykey","text":"'number' keys aren't accepted in the property table of `New`. When you create an instance in Fusion using New , you can pass in a 'property table' containing properties, children, event and property change handlers, etc. This table is only expected to contain keys of two types: string keys, e.g. Name = \"Example\" a few symbol keys, e.g. [ OnEvent \"Foo\" ] = ... This message shows if Fusion finds a key of a different type, or if the key isn't one of the few symbol keys used in New: local folder = New \"Folder\" { [ Vector3 . new ()] = \"Example\" , \"This\" , \"Shouldn't\" , \"Be\" , \"Here\" }","title":"unrecognisedPropertyKey"},{"location":"api-reference/api/children/","text":"local Children : Symbol The symbol used to denote the children of an instance when working with the New function. When using this symbol as a key in New 's property table, the values will be treated as children, and parented according to the rules below. Example Usage \u00b6 local example = New \"Folder\" { [ Children ] = New \"StringValue\" { Value = \"I'm parented to the Folder!\" } } Processing Children \u00b6 A 'child' is defined (recursively) as: an instance a state object or computed object containing children an array of children Since this definition is recursive, arrays and state objects can be nested; that is, the following code is valid: local example = New \"Folder\" { [ Children ] = { { { New \"StringValue\" { Value = \"I'm parented to the Folder!\" } } } } } This behaviour is especially useful when working with components - the following component can return multiple instances to be parented without disrupting the code next to it: local function Component ( props ) return { New \"TextLabel\" { LayoutOrder = 1 , Text = \"Instance one\" }, New \"TextLabel\" { LayoutOrder = 2 , Text = \"Instance two\" } } end local parent = New \"Frame\" { Children = { New \"UIListLayout\" { SortOrder = \"LayoutOrder\" }, Component {} } } When using a state or computed object as a child, it will be bound; when the value of the state object changes, it'll unparent the old children and parent the new children. Note As with bound properties, updates are deferred to the next render step, and so parenting won't occur right away. local child1 = New \"Folder\" { Name = \"Child one\" } local child2 = New \"Folder\" { Name = \"Child two\" } local childState = State ( child1 ) local parent = New \"Folder\" { [ Children ] = childState } print ( parent : GetChildren ()) -- { Child one } childState : set ( child2 ) wait ( 1 ) -- wait for deferred updates to run print ( parent : GetChildren ()) -- { Child two } Warning When using state objects, note that old children won't be destroyed, only unparented - it's up to you to decide if/when children need to be destroyed. If you're using a helper like ComputedPairs , instance cleanup is handled for you by default (though this is configurable).","title":"Children"},{"location":"api-reference/api/children/#example-usage","text":"local example = New \"Folder\" { [ Children ] = New \"StringValue\" { Value = \"I'm parented to the Folder!\" } }","title":"Example Usage"},{"location":"api-reference/api/children/#processing-children","text":"A 'child' is defined (recursively) as: an instance a state object or computed object containing children an array of children Since this definition is recursive, arrays and state objects can be nested; that is, the following code is valid: local example = New \"Folder\" { [ Children ] = { { { New \"StringValue\" { Value = \"I'm parented to the Folder!\" } } } } } This behaviour is especially useful when working with components - the following component can return multiple instances to be parented without disrupting the code next to it: local function Component ( props ) return { New \"TextLabel\" { LayoutOrder = 1 , Text = \"Instance one\" }, New \"TextLabel\" { LayoutOrder = 2 , Text = \"Instance two\" } } end local parent = New \"Frame\" { Children = { New \"UIListLayout\" { SortOrder = \"LayoutOrder\" }, Component {} } } When using a state or computed object as a child, it will be bound; when the value of the state object changes, it'll unparent the old children and parent the new children. Note As with bound properties, updates are deferred to the next render step, and so parenting won't occur right away. local child1 = New \"Folder\" { Name = \"Child one\" } local child2 = New \"Folder\" { Name = \"Child two\" } local childState = State ( child1 ) local parent = New \"Folder\" { [ Children ] = childState } print ( parent : GetChildren ()) -- { Child one } childState : set ( child2 ) wait ( 1 ) -- wait for deferred updates to run print ( parent : GetChildren ()) -- { Child two } Warning When using state objects, note that old children won't be destroyed, only unparented - it's up to you to decide if/when children need to be destroyed. If you're using a helper like ComputedPairs , instance cleanup is handled for you by default (though this is configurable).","title":"Processing Children"},{"location":"api-reference/api/compat/","text":"function Compat ( watchedState : State < any > ): Compat Constructs and returns a new compatibility object, which will listen for events on the given watchedState object. Compat is intended as an API for integrating Fusion with other, non-Fusion code. Some example uses include synchronising theme colours to non-Fusion UIs, or saving state objects to data stores as they change. Warning You should only use Compat when dealing with non-Fusion code. If you're building an interface with Fusion, there are already reactive tools for almost every single use case, which can be better optimised by Fusion and lead to cleaner and more idiomatic code. Using Compat in these situations is highly discouraged. Changing state objects in :onChange() is a particular anti-pattern which abusing Compat may encourage. If you need to update the value of a state object when another state object is changed, consider using computed state instead. For further details, see this issue on GitHub. Parameters \u00b6 watchedState: State<any> - a state object , computed object or other state object to track. Object Methods \u00b6 onChange() \u00b6 function Compat : onChange ( callback : () -> ()): () -> () Connects the given callback as a change handler, and returns a function which will disconnect the callback. When the value of this Compat's watchedState changes, the callback will be fired. Connection memory leaks Make sure to disconnect any change handlers made using this function once you're done using them. As long as a change handler is connected, this Compat object (and the watchedState ) will be held in memory so changes can be detected. This means that, if you don't call the disconnect function, you may end up accidentally holding the state object in memory after you're done using them. Example Usage \u00b6 local numCoins = State ( 50 ) local compat = Compat ( numCoins ) local disconnect = compat : onChange ( function () print ( \"coins is now:\" , numCoins : get ()) end ) numCoins : set ( 25 ) -- prints 'coins is now: 25' -- always clean up your connections! disconnect ()","title":"Compat"},{"location":"api-reference/api/compat/#parameters","text":"watchedState: State<any> - a state object , computed object or other state object to track.","title":"Parameters"},{"location":"api-reference/api/compat/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/api/compat/#onchange","text":"function Compat : onChange ( callback : () -> ()): () -> () Connects the given callback as a change handler, and returns a function which will disconnect the callback. When the value of this Compat's watchedState changes, the callback will be fired. Connection memory leaks Make sure to disconnect any change handlers made using this function once you're done using them. As long as a change handler is connected, this Compat object (and the watchedState ) will be held in memory so changes can be detected. This means that, if you don't call the disconnect function, you may end up accidentally holding the state object in memory after you're done using them.","title":"onChange()"},{"location":"api-reference/api/compat/#example-usage","text":"local numCoins = State ( 50 ) local compat = Compat ( numCoins ) local disconnect = compat : onChange ( function () print ( \"coins is now:\" , numCoins : get ()) end ) numCoins : set ( 25 ) -- prints 'coins is now: 25' -- always clean up your connections! disconnect ()","title":"Example Usage"},{"location":"api-reference/api/computed/","text":"function Computed ( callback : () -> any ): Computed Constructs and returns a new computed object, using the given callback to compute this object's values based on other state objects or computed objects. Parameters \u00b6 callback: () -> any - a function which computes and returns the value to use for this computed object. Object Methods \u00b6 get() \u00b6 function Computed : get (): any Returns the cached value of this computed object, as returned from the callback function. If dependencies are currently being detected (e.g. inside a computed callback), then this computed object will be used as a dependency. Example Usage \u00b6 local numCoins = State ( 50 ) local doubleCoins = Computed ( function () return numCoins : get () * 2 end ) print ( doubleCoins : get ()) --> 100 numCoins : set ( 2 ) print ( doubleCoins : get ()) --> 4 Dependency Management \u00b6 Computed objects automatically detect dependencies used inside their callback each time their callback runs. This means, when you use a function like :get() on a state object, it will register that state object as a dependency: local numCoins = State ( 50 ) local doubleCoins = Computed ( function () -- Fusion detects we called :get() on `numCoins`, and so adds `numCoins` as -- a dependency of this computed object. return numCoins : get () * 2 end ) When a dependency changes value, the computed object will re-run its callback to generate and cache the current value internally. This value is later exposed via the :get() method. Something to note is that dependencies are dynamic; you can change what values your computed object depends on, and the dependencies will be updated to reduce unnecessary updates: Lua local stateA = State ( 5 ) local stateB = State ( 5 ) local selector = State ( \"A\" ) local computed = Computed ( function () print ( \"> updating computed!\" ) local selected = selector : get () if selected == \"A\" then return stateA : get () elseif selected == \"B\" then return stateB : get () end end ) print ( \"increment state A (expect update below)\" ) stateA : set ( stateA : get () + 1 ) print ( \"increment state B (expect no update)\" ) stateB : set ( stateB : get () + 1 ) print ( \"switch to select B\" ) selector : set ( \"B\" ) print ( \"increment state A (expect no update)\" ) stateA : set ( stateA : get () + 1 ) print ( \"increment state B (expect update below)\" ) stateB : set ( stateB : get () + 1 ) Expected output > updating computed! increment state A (expect update below) > updating computed! increment state B (expect no update) switch to select B > updating computed! increment state A (expect no update) increment state B (expect update below) > updating computed! Danger Stick to using state objects and computed objects inside your computations. Fusion can detect when you use these objects and listen for changes. Fusion can't automatically detect changes when you use 'normal' variables: local theVariable = \"Hello\" local badValue = Computed ( function () -- don't do this! use state objects or computed objects in here return \"Say \" .. theVariable end ) print ( badValue : get ()) -- prints 'Say Hello' theVariable = \"World\" print ( badValue : get ()) -- still prints 'Say Hello' - that's a problem! By using a state object here, Fusion can correctly update the computed object, because it knows we used the state object: local theVariable = State ( \"Hello\" ) local goodValue = Computed ( function () -- this is much better - Fusion can detect we used this state object! return \"Say \" .. theVariable : get () end ) print ( goodValue : get ()) -- prints 'Say Hello' theVariable : set ( \"World\" ) print ( goodValue : get ()) -- prints 'Say World' This also applies to any functions that change on their own, like os.clock() . If you need to use them, store values from the function in a state object, and update the value of that object as often as required.","title":"Computed"},{"location":"api-reference/api/computed/#parameters","text":"callback: () -> any - a function which computes and returns the value to use for this computed object.","title":"Parameters"},{"location":"api-reference/api/computed/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/api/computed/#get","text":"function Computed : get (): any Returns the cached value of this computed object, as returned from the callback function. If dependencies are currently being detected (e.g. inside a computed callback), then this computed object will be used as a dependency.","title":"get()"},{"location":"api-reference/api/computed/#example-usage","text":"local numCoins = State ( 50 ) local doubleCoins = Computed ( function () return numCoins : get () * 2 end ) print ( doubleCoins : get ()) --> 100 numCoins : set ( 2 ) print ( doubleCoins : get ()) --> 4","title":"Example Usage"},{"location":"api-reference/api/computed/#dependency-management","text":"Computed objects automatically detect dependencies used inside their callback each time their callback runs. This means, when you use a function like :get() on a state object, it will register that state object as a dependency: local numCoins = State ( 50 ) local doubleCoins = Computed ( function () -- Fusion detects we called :get() on `numCoins`, and so adds `numCoins` as -- a dependency of this computed object. return numCoins : get () * 2 end ) When a dependency changes value, the computed object will re-run its callback to generate and cache the current value internally. This value is later exposed via the :get() method. Something to note is that dependencies are dynamic; you can change what values your computed object depends on, and the dependencies will be updated to reduce unnecessary updates: Lua local stateA = State ( 5 ) local stateB = State ( 5 ) local selector = State ( \"A\" ) local computed = Computed ( function () print ( \"> updating computed!\" ) local selected = selector : get () if selected == \"A\" then return stateA : get () elseif selected == \"B\" then return stateB : get () end end ) print ( \"increment state A (expect update below)\" ) stateA : set ( stateA : get () + 1 ) print ( \"increment state B (expect no update)\" ) stateB : set ( stateB : get () + 1 ) print ( \"switch to select B\" ) selector : set ( \"B\" ) print ( \"increment state A (expect no update)\" ) stateA : set ( stateA : get () + 1 ) print ( \"increment state B (expect update below)\" ) stateB : set ( stateB : get () + 1 ) Expected output > updating computed! increment state A (expect update below) > updating computed! increment state B (expect no update) switch to select B > updating computed! increment state A (expect no update) increment state B (expect update below) > updating computed! Danger Stick to using state objects and computed objects inside your computations. Fusion can detect when you use these objects and listen for changes. Fusion can't automatically detect changes when you use 'normal' variables: local theVariable = \"Hello\" local badValue = Computed ( function () -- don't do this! use state objects or computed objects in here return \"Say \" .. theVariable end ) print ( badValue : get ()) -- prints 'Say Hello' theVariable = \"World\" print ( badValue : get ()) -- still prints 'Say Hello' - that's a problem! By using a state object here, Fusion can correctly update the computed object, because it knows we used the state object: local theVariable = State ( \"Hello\" ) local goodValue = Computed ( function () -- this is much better - Fusion can detect we used this state object! return \"Say \" .. theVariable : get () end ) print ( goodValue : get ()) -- prints 'Say Hello' theVariable : set ( \"World\" ) print ( goodValue : get ()) -- prints 'Say World' This also applies to any functions that change on their own, like os.clock() . If you need to use them, store values from the function in a state object, and update the value of that object as often as required.","title":"Dependency Management"},{"location":"api-reference/api/computedpairs/","text":"function ComputedPairs ( inputTable : StateOrValue < {[ any ]: any } > , processor : ( key : any , value : any ) -> any , destructor : (( any ) -> any ) ? ): Computed Constructs and returns a new computed object, which generates a table by processing values from another table. The input table may be passed in directly, or inside a state object or computed object. The output table will have all the keys of the input table, but all the values will be passed through the processor function. When values are removed from the output table, they may optionally be passed through a destructor function. This allows you to properly clean up some types such as instances - more details can be found in the tutorial. Parameters \u00b6 inputTable: StateOrValue<{[any]: any}> - a table, or state object containing a table, which will be read by this ComputedPairs processor: (key: any, value: any) -> any - values from the input table will be passed through this function and placed in the table returned by this object destructor: ((any) -> any)? - when a value is removed from the output table, it will be passed to this function for cleanup. If not provided, defaults to a Maid-like cleanup function. Object Methods \u00b6 get() \u00b6 function ComputedPairs : get (): any Returns the cached value of this computed object, which will be the output table of key/value pairs. If dependencies are currently being detected (e.g. inside a computed callback), then this computed object will be used as a dependency. Example Usage \u00b6 local playerList = State ({ \"AxisAngles\" , \"boatbomber\" , \"Elttob\" , \"grilme99\" , \"Phalanxia\" , \"Reselim\" , \"thisfall\" }) local textLabels = ComputedPairs ( playerList , function ( key , value ) return New \"TextLabel\" { Text = value } end )","title":"ComputedPairs"},{"location":"api-reference/api/computedpairs/#parameters","text":"inputTable: StateOrValue<{[any]: any}> - a table, or state object containing a table, which will be read by this ComputedPairs processor: (key: any, value: any) -> any - values from the input table will be passed through this function and placed in the table returned by this object destructor: ((any) -> any)? - when a value is removed from the output table, it will be passed to this function for cleanup. If not provided, defaults to a Maid-like cleanup function.","title":"Parameters"},{"location":"api-reference/api/computedpairs/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/api/computedpairs/#get","text":"function ComputedPairs : get (): any Returns the cached value of this computed object, which will be the output table of key/value pairs. If dependencies are currently being detected (e.g. inside a computed callback), then this computed object will be used as a dependency.","title":"get()"},{"location":"api-reference/api/computedpairs/#example-usage","text":"local playerList = State ({ \"AxisAngles\" , \"boatbomber\" , \"Elttob\" , \"grilme99\" , \"Phalanxia\" , \"Reselim\" , \"thisfall\" }) local textLabels = ComputedPairs ( playerList , function ( key , value ) return New \"TextLabel\" { Text = value } end )","title":"Example Usage"},{"location":"api-reference/api/new/","text":"function New ( className : string ): ( props : {[ string | Symbol ]: any }) -> Instance Constructs and returns a new instance, with options for setting properties, event handlers and other attributes on the instance right away. The function has curried parameters - when calling New with the className parameter, it'll return a second function accepting the props parameter. This is done to take advantage of some function call syntax sugar in Lua: local myInstance = New ( \"Frame\" )({...}) -- is equivalent to: local myInstance = New \"Frame\" {...} Instance cleanup Make sure to destroy your instances properly. Without using an explicit :Destroy() , it's easy to accidentally introduce memory leaks. For lists of instances, you can use ComputedPairs , which comes with good defaults for instance caching and cleanup. Parameters \u00b6 className: string - the class type of instance to create props: {[string | Symbol]: any} - a table of properties, event handlers and other attributes to apply to the instance Example Usage \u00b6 local myButton : TextButton = New \"TextButton\" { Parent = Players . LocalPlayer . PlayerGui , Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Hello, world!\" , [ OnEvent \"Activated\" ] = function () print ( \"The button was clicked!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"The button was renamed to:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } } Passing In Properties \u00b6 The props table uses a mix of string and symbol keys to specify attributes of the instance which should be set. String keys are treated as property declarations - values passed in will be set upon the instance: local example = New \"Part\" { -- sets the Position property Position = Vector3 . new ( 1 , 2 , 3 ) } Additionally, passing in state objects or computed objects will bind the property value; when the value of the object changes, the property will also update on the next render step: local myName = State ( \"Bob\" ) local example = New \"Part\" { -- initially, the Name will be set to Bob Name = myName } -- change the state object to store \"John\" -- on the next render step, the part's Name will change to John myName : set ( \"John\" ) Fusion provides additional symbol keys for other, specialised purposes - see their documentation for more info on how each one works: Children - parents other instances into this instance OnEvent - connects a callback to an event on this instance OnChange - connects a callback to the GetPropertyChangedSignal event for a property on this instance Default Properties \u00b6 The New function provides its own set of 'sensible default' property values for some class types, which will be used in place of Roblox defaults. This is done to opt out of some legacy features and unhelpful defaults. You can see the default properties Fusion uses here: Default properties ScreenGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" }, BillboardGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" }, SurfaceGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , SizingMode = \"PixelsPerStud\" , PixelsPerStud = 50 }, Frame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, ScrollingFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , ScrollBarImageColor3 = Color3 . new ( 0 , 0 , 0 ) }, TextLabel = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, TextButton = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , AutoButtonColor = false , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, TextBox = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , ClearTextOnFocus = false , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, ImageLabel = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, ImageButton = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , AutoButtonColor = false }, ViewportFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, VideoFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }","title":"New"},{"location":"api-reference/api/new/#parameters","text":"className: string - the class type of instance to create props: {[string | Symbol]: any} - a table of properties, event handlers and other attributes to apply to the instance","title":"Parameters"},{"location":"api-reference/api/new/#example-usage","text":"local myButton : TextButton = New \"TextButton\" { Parent = Players . LocalPlayer . PlayerGui , Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Hello, world!\" , [ OnEvent \"Activated\" ] = function () print ( \"The button was clicked!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"The button was renamed to:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } }","title":"Example Usage"},{"location":"api-reference/api/new/#passing-in-properties","text":"The props table uses a mix of string and symbol keys to specify attributes of the instance which should be set. String keys are treated as property declarations - values passed in will be set upon the instance: local example = New \"Part\" { -- sets the Position property Position = Vector3 . new ( 1 , 2 , 3 ) } Additionally, passing in state objects or computed objects will bind the property value; when the value of the object changes, the property will also update on the next render step: local myName = State ( \"Bob\" ) local example = New \"Part\" { -- initially, the Name will be set to Bob Name = myName } -- change the state object to store \"John\" -- on the next render step, the part's Name will change to John myName : set ( \"John\" ) Fusion provides additional symbol keys for other, specialised purposes - see their documentation for more info on how each one works: Children - parents other instances into this instance OnEvent - connects a callback to an event on this instance OnChange - connects a callback to the GetPropertyChangedSignal event for a property on this instance","title":"Passing In Properties"},{"location":"api-reference/api/new/#default-properties","text":"The New function provides its own set of 'sensible default' property values for some class types, which will be used in place of Roblox defaults. This is done to opt out of some legacy features and unhelpful defaults. You can see the default properties Fusion uses here: Default properties ScreenGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" }, BillboardGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" }, SurfaceGui = { ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , SizingMode = \"PixelsPerStud\" , PixelsPerStud = 50 }, Frame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, ScrollingFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , ScrollBarImageColor3 = Color3 . new ( 0 , 0 , 0 ) }, TextLabel = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, TextButton = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , AutoButtonColor = false , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, TextBox = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , ClearTextOnFocus = false , Font = \"SourceSans\" , Text = \"\" , TextColor3 = Color3 . new ( 0 , 0 , 0 ), TextSize = 14 }, ImageLabel = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, ImageButton = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 , AutoButtonColor = false }, ViewportFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }, VideoFrame = { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), BorderColor3 = Color3 . new ( 0 , 0 , 0 ), BorderSizePixel = 0 }","title":"Default Properties"},{"location":"api-reference/api/onchange/","text":"function OnChange ( propertyName : string ): Symbol Generates symbols used to denote property change handlers when working with the New function. When using this symbol as a key in New 's property table, the value is expected to be a callback function. The callback will be connected to the property's GetPropertyChangedSignal event on the instance. Unlike normal property change handlers, the new value is passed in as an argument to the callback for convenience. Using OnChange with bound state When passing a state object or computed object as a property, changes in the state will only affect the property on the next render step (a concept known as 'deferred updating'). Because OnChange connects to GetPropertyChangedSignal , it's possible to introduce subtle off-by-one-frame errors if you depend on OnChange to keep other things in sync with the property. Prefer to connect to the state's onChange event instead. Parameters \u00b6 propertyName: string - the property to watch for changes on the instance Example Usage \u00b6 local example = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end }","title":"OnChange"},{"location":"api-reference/api/onchange/#parameters","text":"propertyName: string - the property to watch for changes on the instance","title":"Parameters"},{"location":"api-reference/api/onchange/#example-usage","text":"local example = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end }","title":"Example Usage"},{"location":"api-reference/api/onevent/","text":"function OnEvent ( eventName : string ): Symbol Generates symbols used to denote event handlers when working with the New function. When using this symbol as a key in New 's property table, the value is expected to be a callback function, which will be connected to the given event on the instance. The function acts as a normal event handler does; it receives all arguments from the event. The connection is automatically cleaned up when the instance is destroyed. Parameters \u00b6 eventName: string - the name of the event on the instance Example Usage \u00b6 local example = New \"TextButton\" { [ OnEvent \"Activated\" ] = function (...) print ( \"Activated event fired with args:\" , ...) end }","title":"OnEvent"},{"location":"api-reference/api/onevent/#parameters","text":"eventName: string - the name of the event on the instance","title":"Parameters"},{"location":"api-reference/api/onevent/#example-usage","text":"local example = New \"TextButton\" { [ OnEvent \"Activated\" ] = function (...) print ( \"Activated event fired with args:\" , ...) end }","title":"Example Usage"},{"location":"api-reference/api/spring/","text":"function Spring ( goalValue : State < Animatable > , speed : number ? , dampingRatio : number ? ): Spring Constructs and returns a new Spring state object, which follows the value of goalValue . The value of this object is simulated physically, as if linked to the goal value by a damped spring. speed acts like a time multiplier; doubling speed corresponds to movement which is twice as fast. dampingRatio affects the friction; 0 represents no friction, and 1 is just enough friction to reach the goal without overshooting or oscillating. This can be varied freely to fine-tune how much friction or 'bounce' your motion has. Parameters \u00b6 goalValue: State<Animatable> - the goal value this object should approach speed: number? - how fast this object should approach the goal dampingRatio: number? - scales how much friction is applied Object Methods \u00b6 get() \u00b6 function Spring : get (): any Returns the currently stored value of this Spring state object. If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency. Example Usage \u00b6 local position = State ( UDim2 . fromScale ( 0.25 , 0.25 )) local ui = New \"Frame\" { Position = Spring ( position , 25 , 0.5 ) } local playerCount = State ( 0 ) local smoothPlayerCount = Spring ( playerCount ) local message = Computed ( function () return \"Currently online: \" .. math.floor ( smoothPlayerCount : get ()) end )","title":"Spring"},{"location":"api-reference/api/spring/#parameters","text":"goalValue: State<Animatable> - the goal value this object should approach speed: number? - how fast this object should approach the goal dampingRatio: number? - scales how much friction is applied","title":"Parameters"},{"location":"api-reference/api/spring/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/api/spring/#get","text":"function Spring : get (): any Returns the currently stored value of this Spring state object. If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency.","title":"get()"},{"location":"api-reference/api/spring/#example-usage","text":"local position = State ( UDim2 . fromScale ( 0.25 , 0.25 )) local ui = New \"Frame\" { Position = Spring ( position , 25 , 0.5 ) } local playerCount = State ( 0 ) local smoothPlayerCount = Spring ( playerCount ) local message = Computed ( function () return \"Currently online: \" .. math.floor ( smoothPlayerCount : get ()) end )","title":"Example Usage"},{"location":"api-reference/api/state/","text":"function State ( initialValue : any ? ): State Constructs and returns a new state object, with an optional initial value. Parameters \u00b6 initialValue: any? - the value which should initially be stored in the state object. Object Methods \u00b6 get() \u00b6 function State : get (): any Returns the currently stored value of this state object. If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency. set() \u00b6 function State : set ( newValue : any , force : boolean ? ) Sets the new value of this state object. If the new and old values differ, this will update any other objects using this state object. However, if they're the same, no update will be performed. Force updating If you want to override this behaviour, you can set force to true . This will ensure updates are always performed, even if the new and old values are the same (as measured by the == operator). This is most useful when working with mutable tables. However, be very careful with this, and only force updates when you need to for performance reasons. Try a solution involving immutable tables first. Abuse of force updating can lead to suboptimal code that updates redundantly. Example Usage \u00b6 local numCoins = State ( 50 ) print ( numCoins : get ()) --> 50 numCoins : set ( 25 ) print ( numCoins : get ()) --> 25 numCoins . onChange : Connect ( function () print ( \"Coins changed to:\" , numCoins : get ()) end )","title":"State"},{"location":"api-reference/api/state/#parameters","text":"initialValue: any? - the value which should initially be stored in the state object.","title":"Parameters"},{"location":"api-reference/api/state/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/api/state/#get","text":"function State : get (): any Returns the currently stored value of this state object. If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency.","title":"get()"},{"location":"api-reference/api/state/#set","text":"function State : set ( newValue : any , force : boolean ? ) Sets the new value of this state object. If the new and old values differ, this will update any other objects using this state object. However, if they're the same, no update will be performed. Force updating If you want to override this behaviour, you can set force to true . This will ensure updates are always performed, even if the new and old values are the same (as measured by the == operator). This is most useful when working with mutable tables. However, be very careful with this, and only force updates when you need to for performance reasons. Try a solution involving immutable tables first. Abuse of force updating can lead to suboptimal code that updates redundantly.","title":"set()"},{"location":"api-reference/api/state/#example-usage","text":"local numCoins = State ( 50 ) print ( numCoins : get ()) --> 50 numCoins : set ( 25 ) print ( numCoins : get ()) --> 25 numCoins . onChange : Connect ( function () print ( \"Coins changed to:\" , numCoins : get ()) end )","title":"Example Usage"},{"location":"api-reference/api/tween/","text":"function Tween ( goalValue : State < Animatable > , tweenInfo : TweenInfo ? ): Tween Constructs and returns a new Tween state object, which follows the value of goalValue . When the goal value changes, the value of this object is tweened towards the goal value using the given tweenInfo . Parameters \u00b6 goalValue: State<Animatable> - the goal value this object should approach tweenInfo: TweenInfo? - the tween to use when animating this object's value Object Methods \u00b6 get() \u00b6 function Tween : get (): any Returns the currently stored value of this Tween state object. If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency. Example Usage \u00b6 local EASE = TweenInfo . new ( 0.5 , Enum . EasingStyle . Sine , Enum . EasingDirection . InOut ) local position = State ( UDim2 . fromScale ( 0.25 , 0.25 )) local ui = New \"Frame\" { Position = Tween ( position , EASE ) } local playerCount = State ( 0 ) local smoothPlayerCount = Tween ( playerCount ) local message = Computed ( function () return \"Currently online: \" .. math.floor ( smoothPlayerCount : get ()) end )","title":"Tween"},{"location":"api-reference/api/tween/#parameters","text":"goalValue: State<Animatable> - the goal value this object should approach tweenInfo: TweenInfo? - the tween to use when animating this object's value","title":"Parameters"},{"location":"api-reference/api/tween/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/api/tween/#get","text":"function Tween : get (): any Returns the currently stored value of this Tween state object. If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency.","title":"get()"},{"location":"api-reference/api/tween/#example-usage","text":"local EASE = TweenInfo . new ( 0.5 , Enum . EasingStyle . Sine , Enum . EasingDirection . InOut ) local position = State ( UDim2 . fromScale ( 0.25 , 0.25 )) local ui = New \"Frame\" { Position = Tween ( position , EASE ) } local playerCount = State ( 0 ) local smoothPlayerCount = Tween ( playerCount ) local message = Computed ( function () return \"Currently online: \" .. math.floor ( smoothPlayerCount : get ()) end )","title":"Example Usage"},{"location":"examples/","text":"Under construction This page is under construction - information may be incomplete or missing. Welcome to the Examples page! Here, you can find various open-source examples and projects, so you can see how Fusion works in a real setting. Fusion Obby \u00b6 See how Fusion can be used to build a minimal interface for an obby, with an animated checkpoint counter and simulated confetti. Click here to view and edit the game on Roblox.","title":"Home"},{"location":"examples/#fusion-obby","text":"See how Fusion can be used to build a minimal interface for an obby, with an animated checkpoint counter and simulated confetti. Click here to view and edit the game on Roblox.","title":"Fusion Obby"},{"location":"extras/","text":"Extras \u00b6 Welcome to the Extras section! Here, you can find guidelines and assets for Fusion branding, download backgrounds and wallpapers for your devices, and more! Commonly Used \u00b6 Backgrounds Brand Guidelines","title":"Home"},{"location":"extras/#extras","text":"Welcome to the Extras section! Here, you can find guidelines and assets for Fusion branding, download backgrounds and wallpapers for your devices, and more!","title":"Extras"},{"location":"extras/#commonly-used","text":"Backgrounds Brand Guidelines","title":"Commonly Used"},{"location":"extras/backgrounds/","text":"All backgrounds are PNG format, and have been optimised for these resolutions: Ultrawide (7680 x 1440) Widescreen (2560 x 1440) 3:2 (2256 x 1504) Mobile (1125 x 2436) These backgrounds are intended for personal use only! These backgrounds are, and remain, the copyright of Elttob. You may not use these, commercially or otherwise, without explicit written consent. Extrusion \u00b6 A Fusion logo, with extruded fill lines coming out of the logo. Background is hex colour #0D0D0F, and so might not be ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Construction \u00b6 The Fusion logo, with construction lines shown and other geometric patterns. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Glow \u00b6 A centred Fusion logo emitting light on a dark background. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Glow (Alternate) \u00b6 A centred Fusion logo emitting light on a dark background. Uses an alternate design of the logo, which is now used for livestreams. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Backgrounds"},{"location":"extras/backgrounds/#extrusion","text":"A Fusion logo, with extruded fill lines coming out of the logo. Background is hex colour #0D0D0F, and so might not be ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Extrusion"},{"location":"extras/backgrounds/#construction","text":"The Fusion logo, with construction lines shown and other geometric patterns. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Construction"},{"location":"extras/backgrounds/#glow","text":"A centred Fusion logo emitting light on a dark background. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Glow"},{"location":"extras/backgrounds/#glow-alternate","text":"A centred Fusion logo emitting light on a dark background. Uses an alternate design of the logo, which is now used for livestreams. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Glow (Alternate)"},{"location":"extras/brand-guidelines/","text":"Under construction This page is under construction - information may be incomplete or missing. Fusion is a modern, lightweight library built to make UI development faster and accessible to more people. The Fusion brand is designed to reflect these themes. (TODO: add brand asset download link here) Elements \u00b6 Stub This section is a stub - it may require more detail added to it in future. The Fusion logo \u00b6 Our logo is constructed from two perpendicular intersecting planes, viewed from an almost-isometric angle. This represents how Fusion brings together two different data structures into one unified whole; Fusion connects the hierachy of instances to the hierachy of state objects. The logo is designed on an 8x8 pixel grid, making it highly legible and recognisable at almost any size. The colours chosen are energetic and warm, giving Fusion a uniquely hot colour palette compared to the cool blues of most other libraries and frameworks. It\u2019s a simple, abstract design, but stands out among many other Roblox libraries by not depending on the Roblox brand. Using Fusion brand assets \u00b6 Before using the Fusion logo or brand assets in your project, please be mindful of our policy around use of our branding. The rights to the Fusion name, logo and brand assets remain reserved by Elttob. We allow the following uses of the Fusion logo and branding by default: Representing the (original) Fusion project. For example, you may use the the Fusion logo on-screen in a tutorial video when you're referring to the Fusion project... ...as an image in a news article or blog post where you are talking about the Fusion project... ...as an icon in a data visualisation to represent the Fusion project... ...or in general, any use where it's very clear you're referring to the Fusion project. This does not extend to derived or inspired-by projects. If you wish to use the Fusion logo, name or branding in your project for a use case which isn't listed above, you must receive explicit written permission from Elttob first. Please do not use the logo or branding in a way that: may insinuate support, endorsement or other affiliation with the Fusion project. It's okay to say you were inspired by Fusion, or are using Fusion as part of your project... ...but it's not okay if your project comes off as an official part of Fusion, or as something officially endorsed by the Fusion project.","title":"Brand Guidelines"},{"location":"extras/brand-guidelines/#elements","text":"Stub This section is a stub - it may require more detail added to it in future.","title":"Elements"},{"location":"extras/brand-guidelines/#the-fusion-logo","text":"Our logo is constructed from two perpendicular intersecting planes, viewed from an almost-isometric angle. This represents how Fusion brings together two different data structures into one unified whole; Fusion connects the hierachy of instances to the hierachy of state objects. The logo is designed on an 8x8 pixel grid, making it highly legible and recognisable at almost any size. The colours chosen are energetic and warm, giving Fusion a uniquely hot colour palette compared to the cool blues of most other libraries and frameworks. It\u2019s a simple, abstract design, but stands out among many other Roblox libraries by not depending on the Roblox brand.","title":"The Fusion logo"},{"location":"extras/brand-guidelines/#using-fusion-brand-assets","text":"Before using the Fusion logo or brand assets in your project, please be mindful of our policy around use of our branding. The rights to the Fusion name, logo and brand assets remain reserved by Elttob. We allow the following uses of the Fusion logo and branding by default: Representing the (original) Fusion project. For example, you may use the the Fusion logo on-screen in a tutorial video when you're referring to the Fusion project... ...as an image in a news article or blog post where you are talking about the Fusion project... ...as an icon in a data visualisation to represent the Fusion project... ...or in general, any use where it's very clear you're referring to the Fusion project. This does not extend to derived or inspired-by projects. If you wish to use the Fusion logo, name or branding in your project for a use case which isn't listed above, you must receive explicit written permission from Elttob first. Please do not use the logo or branding in a way that: may insinuate support, endorsement or other affiliation with the Fusion project. It's okay to say you were inspired by Fusion, or are using Fusion as part of your project... ...but it's not okay if your project comes off as an official part of Fusion, or as something officially endorsed by the Fusion project.","title":"Using Fusion brand assets"},{"location":"tutorials/","text":"Welcome to the Fusion tutorial section! Here, you'll learn how to build great interfaces with Fusion, even if you're a complete newcomer to the library. Early Beta Fusion is highly work-in-progress right now. There are a lot of features that don't work, aren't implemented, aren't documented fully or which may be tweaked or removed. We don't recommend using Fusion for any major project right now unless you're willing to take on the extra work of following these changes. More stable, long-term-supported Fusion versions will be available once Fusion exits beta testing. What You Need To Know \u00b6 These tutorials assume: You're comfortable with Roblox and the Luau scripting language. These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub . You're familiar with how UI works on Roblox. You don't have to be a designer - knowing about UI instances, events and data types like UDim2 and Color3 will be good enough. Of course, based on your existing knowledge, you may find some tutorials easier or harder. Fusion's built to be easy to learn, but it may still take a bit of time to absorb some concepts, so don't be discouraged \ud83d\ude42 How These Tutorials Work \u00b6 You can find the tutorials in the navigation bar to your left. Tutorials are grouped together by category, and are designed to explore specific features of Fusion: 'Fundamentals' introduces the core ideas of Fusion - making instances, storing state and responding to events. 'Further Basics' builds on those core ideas by adding in useful utilities for building more complex UIs. 'Animation' demonstrates how to add tweens, transitions and spring physics to bring your UI to life. You can either do them in order (recommended for newcomers), or you can jump to a specific tutorial for a quick refresh. You'll also see 'projects', which combine concepts from earlier tutorials and show how they interact and work together in a real setting. At the beginning of every tutorial, you'll see a section titled 'Required code'. They look like this - you can click to expand them: Required code 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"This is an example!\" ) Before starting each tutorial, make sure to copy the code into your script editor, so you can follow along properly. Similarly, you'll find the finished code for the tutorial at the end, under 'Finished code': Finished code 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"This is an example!\" ) print ( \"Pretend we added some code during the tutorial here...\" ) You can use the finished code as a reference if you get stuck - it'll contain the script as it appears after following all the steps of the tutorial. Installing Fusion \u00b6 Fusion is distributed as a single ModuleScript . Before starting, you'll need to add this module script to your game. Here's how: Fusion for Roblox Studio \u00b6 If you script in Roblox Studio, here's how to install Fusion: Steps Head over to Fusion's 'Releases' page . There, you can find the latest version of Fusion. Under 'Assets', click the .rbxm file to download it. This contains the Fusion module script. In Roblox Studio, open or create a place. Right-click on ReplicatedStorage, and select 'Insert from File'. Find the .rbxm you just downloaded, and select it. You should now see a ModuleScript called 'Fusion' sitting in ReplicatedStorage - you're ready to go! Fusion for External Editors \u00b6 If you use an external editor to write scripts, and synchronise them into Roblox using a plugin, here's how to install Fusion: Steps (click to expand) Head over to Fusion's 'Releases' page . There, you can find the latest version of Fusion. Under 'Assets', click the .zip file to download it. Inside is a copy of the Fusion GitHub repository. Inside the zip, copy the src folder - it may be in a nested folder. Paste src into your local project, preferably in your shared folder if you have one. Rename the folder from src to Fusion . Once everything is set up, you should see Fusion appear in Studio when you next synchronise your project. Setting Up A Test Script \u00b6 Now that you've installed Fusion, you can set up a local script for testing. Here's how: Create a LocalScript in a service like StarterGui or StarterPlayerScripts . Remove the default code, and paste the following code in: 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Note This code assumes you've installed Fusion into ReplicatedStorage. If you've installed Fusion elsewhere, you'll need to tweak the require() to point to the correct location. If everything was set up correctly, you can press 'Play' and everything should run without any errors. My script doesn't work - common errors Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\" If you're seeing this error, then your script can't find Fusion. Refer back to the previous section and double-check you've set everything up properly. If you're using the installation guide from above, your ReplicatedStorage should look like this: Where To Get Help \u00b6 Fusion is built to be easy to use, and we want these tutorials to be as useful and comprehensive as possible. However, maybe you're stuck on a cursed issue and really need some help; or perhaps you're looking to get a better overall understanding of Fusion! Whatever you're looking for, here are some resources for you to get help: The Roblox OSS Discord has a #fusion channel Check out our Discussions page on GitHub Open an issue if you run into bugs or have feature requests","title":"Get Started"},{"location":"tutorials/#what-you-need-to-know","text":"These tutorials assume: You're comfortable with Roblox and the Luau scripting language. These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub . You're familiar with how UI works on Roblox. You don't have to be a designer - knowing about UI instances, events and data types like UDim2 and Color3 will be good enough. Of course, based on your existing knowledge, you may find some tutorials easier or harder. Fusion's built to be easy to learn, but it may still take a bit of time to absorb some concepts, so don't be discouraged \ud83d\ude42","title":"What You Need To Know"},{"location":"tutorials/#how-these-tutorials-work","text":"You can find the tutorials in the navigation bar to your left. Tutorials are grouped together by category, and are designed to explore specific features of Fusion: 'Fundamentals' introduces the core ideas of Fusion - making instances, storing state and responding to events. 'Further Basics' builds on those core ideas by adding in useful utilities for building more complex UIs. 'Animation' demonstrates how to add tweens, transitions and spring physics to bring your UI to life. You can either do them in order (recommended for newcomers), or you can jump to a specific tutorial for a quick refresh. You'll also see 'projects', which combine concepts from earlier tutorials and show how they interact and work together in a real setting. At the beginning of every tutorial, you'll see a section titled 'Required code'. They look like this - you can click to expand them: Required code 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"This is an example!\" ) Before starting each tutorial, make sure to copy the code into your script editor, so you can follow along properly. Similarly, you'll find the finished code for the tutorial at the end, under 'Finished code': Finished code 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) print ( \"This is an example!\" ) print ( \"Pretend we added some code during the tutorial here...\" ) You can use the finished code as a reference if you get stuck - it'll contain the script as it appears after following all the steps of the tutorial.","title":"How These Tutorials Work"},{"location":"tutorials/#installing-fusion","text":"Fusion is distributed as a single ModuleScript . Before starting, you'll need to add this module script to your game. Here's how:","title":"Installing Fusion"},{"location":"tutorials/#fusion-for-roblox-studio","text":"If you script in Roblox Studio, here's how to install Fusion: Steps Head over to Fusion's 'Releases' page . There, you can find the latest version of Fusion. Under 'Assets', click the .rbxm file to download it. This contains the Fusion module script. In Roblox Studio, open or create a place. Right-click on ReplicatedStorage, and select 'Insert from File'. Find the .rbxm you just downloaded, and select it. You should now see a ModuleScript called 'Fusion' sitting in ReplicatedStorage - you're ready to go!","title":"Fusion for Roblox Studio"},{"location":"tutorials/#fusion-for-external-editors","text":"If you use an external editor to write scripts, and synchronise them into Roblox using a plugin, here's how to install Fusion: Steps (click to expand) Head over to Fusion's 'Releases' page . There, you can find the latest version of Fusion. Under 'Assets', click the .zip file to download it. Inside is a copy of the Fusion GitHub repository. Inside the zip, copy the src folder - it may be in a nested folder. Paste src into your local project, preferably in your shared folder if you have one. Rename the folder from src to Fusion . Once everything is set up, you should see Fusion appear in Studio when you next synchronise your project.","title":"Fusion for External Editors"},{"location":"tutorials/#setting-up-a-test-script","text":"Now that you've installed Fusion, you can set up a local script for testing. Here's how: Create a LocalScript in a service like StarterGui or StarterPlayerScripts . Remove the default code, and paste the following code in: 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Note This code assumes you've installed Fusion into ReplicatedStorage. If you've installed Fusion elsewhere, you'll need to tweak the require() to point to the correct location. If everything was set up correctly, you can press 'Play' and everything should run without any errors. My script doesn't work - common errors Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\" If you're seeing this error, then your script can't find Fusion. Refer back to the previous section and double-check you've set everything up properly. If you're using the installation guide from above, your ReplicatedStorage should look like this:","title":"Setting Up A Test Script"},{"location":"tutorials/#where-to-get-help","text":"Fusion is built to be easy to use, and we want these tutorials to be as useful and comprehensive as possible. However, maybe you're stuck on a cursed issue and really need some help; or perhaps you're looking to get a better overall understanding of Fusion! Whatever you're looking for, here are some resources for you to get help: The Roblox OSS Discord has a #fusion channel Check out our Discussions page on GitHub Open an issue if you run into bugs or have feature requests","title":"Where To Get Help"},{"location":"tutorials/animation/project-3/","text":"Under construction This page is under construction - information may be incomplete or missing.","title":"Project 3: Switches"},{"location":"tutorials/animation/springs/","text":"Under construction This page is under construction - information may be incomplete or missing.","title":"Springs"},{"location":"tutorials/animation/tweens/","text":"Under construction This page is under construction - information may be incomplete or missing.","title":"Tweens"},{"location":"tutorials/fundamentals/changing-children/","text":"Under construction This page is under construction - information may be incomplete or missing. Passing State To Children \u00b6 Stub This section is a stub - it may require more detail added to it in future. Previously, we found that we could pass state objects as properties to bind them: local message = State ( \"Hello\" ) local gui = New \"TextLabel\" { Text = message } message : set ( \"World\" ) -- sets Text to World The same principle works for [Children] - you can pass in a state object containing any children you'd like to add, and they'll be bound similarly: local child = State ( New \"Folder\" {}) local gui = New \"TextLabel\" { [ Children ] = child } child : set ( New \"ScreenGui\" {}) -- changes the child from the folder to the screen gui local child1 = New \"Folder\" {} local child2 = New \"Folder\" {} local child3 = New \"Folder\" {} local children = State ({ child1 , child2 }) local gui = New \"TextLabel\" { [ Children ] = children } children : set ({ child2 , child3 }) -- unparents child1, parents child2 Note that when a child is removed like this, it is only unparented, not destroyed. Make sure to destroy any instances you remove if you're not using a helper like ComputedPairs. Deferred Updates \u00b6 Stub This section is a stub - it may require more detail added to it in future. Changes to bound children are deferred until the next render step, just like changes to bound properties.","title":"Changing Children"},{"location":"tutorials/fundamentals/changing-children/#passing-state-to-children","text":"Stub This section is a stub - it may require more detail added to it in future. Previously, we found that we could pass state objects as properties to bind them: local message = State ( \"Hello\" ) local gui = New \"TextLabel\" { Text = message } message : set ( \"World\" ) -- sets Text to World The same principle works for [Children] - you can pass in a state object containing any children you'd like to add, and they'll be bound similarly: local child = State ( New \"Folder\" {}) local gui = New \"TextLabel\" { [ Children ] = child } child : set ( New \"ScreenGui\" {}) -- changes the child from the folder to the screen gui local child1 = New \"Folder\" {} local child2 = New \"Folder\" {} local child3 = New \"Folder\" {} local children = State ({ child1 , child2 }) local gui = New \"TextLabel\" { [ Children ] = children } children : set ({ child2 , child3 }) -- unparents child1, parents child2 Note that when a child is removed like this, it is only unparented, not destroyed. Make sure to destroy any instances you remove if you're not using a helper like ComputedPairs.","title":"Passing State To Children"},{"location":"tutorials/fundamentals/changing-children/#deferred-updates","text":"Stub This section is a stub - it may require more detail added to it in future. Changes to bound children are deferred until the next render step, just like changes to bound properties.","title":"Deferred Updates"},{"location":"tutorials/fundamentals/changing-properties/","text":"Now that we know how to represent and work with UI state, let's learn how to link up properties to our UI state so we can display a message on-screen. Required code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" online.\" end ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ) } } Passing State To Properties \u00b6 In our current code, we're using state and computed objects to store and process some data: 11 12 13 14 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" online.\" end ) When we use the New function, we can use these state objects as properties. In other words, we can set the Text of our label to be our message state: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" online.\" end ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = message } } This will set the Text to whatever's stored in message , and keeps it updated as message is changed. To keep things neat and tidy, you can create the computed object directly next to the property instead, to keep it close to where it's used: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local numPlayers = State ( 5 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = Computed ( function () return \"There are \" .. numPlayers : get () .. \" online.\" end ) } } That's all you need to know - it's trivial to use any state as a property when using the New function. Deferred Updates \u00b6 It's worth noting that property changes aren't applied right away - they're deferred until the next render step. In this example, the value of the state object is changed many times. However, Fusion will only update the property at the next render step, meaning we only see the last change have an effect: Lua local state = State ( 1 ) local ins = New \"NumberValue\" { Value = state , [ OnChange \"Value\" ] = function ( newValue ) print ( \"Value is now:\" , newValue ) end ) } state : set ( 2 ) state : set ( 3 ) state : set ( 4 ) state : set ( 5 ) Expected output Value is now: 5 This is done for optimisation purposes; while it's relatively cheap to update state objects many times per frame, it's expensive to update instances. Furthermore, there's no reason to update an instance many times per frame, since it'll only be rendered once. In almost all cases, this is a desirable optimisation. However, in a select few cases, it can be problematic. Specifically, in the above example, the OnChange handler is not fired every time the state object changes value. Instead, it's fired in the render step after the state object is changed, because that's when the property actually changes. This can lead to subtle off-by-one-frame errors if you're not careful, so be cautious about using OnChange on properties you also bind state to. That's everything you need to know about connecting properties with state - it's a simple concept, but fundamental to creating dynamic and interactive UIs. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = Computed ( function () return \"There are \" .. numPlayers : get () .. \" online.\" end ) } }","title":"Changing Properties"},{"location":"tutorials/fundamentals/changing-properties/#passing-state-to-properties","text":"In our current code, we're using state and computed objects to store and process some data: 11 12 13 14 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" online.\" end ) When we use the New function, we can use these state objects as properties. In other words, we can set the Text of our label to be our message state: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" online.\" end ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = message } } This will set the Text to whatever's stored in message , and keeps it updated as message is changed. To keep things neat and tidy, you can create the computed object directly next to the property instead, to keep it close to where it's used: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local numPlayers = State ( 5 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = Computed ( function () return \"There are \" .. numPlayers : get () .. \" online.\" end ) } } That's all you need to know - it's trivial to use any state as a property when using the New function.","title":"Passing State To Properties"},{"location":"tutorials/fundamentals/changing-properties/#deferred-updates","text":"It's worth noting that property changes aren't applied right away - they're deferred until the next render step. In this example, the value of the state object is changed many times. However, Fusion will only update the property at the next render step, meaning we only see the last change have an effect: Lua local state = State ( 1 ) local ins = New \"NumberValue\" { Value = state , [ OnChange \"Value\" ] = function ( newValue ) print ( \"Value is now:\" , newValue ) end ) } state : set ( 2 ) state : set ( 3 ) state : set ( 4 ) state : set ( 5 ) Expected output Value is now: 5 This is done for optimisation purposes; while it's relatively cheap to update state objects many times per frame, it's expensive to update instances. Furthermore, there's no reason to update an instance many times per frame, since it'll only be rendered once. In almost all cases, this is a desirable optimisation. However, in a select few cases, it can be problematic. Specifically, in the above example, the OnChange handler is not fired every time the state object changes value. Instead, it's fired in the render step after the state object is changed, because that's when the property actually changes. This can lead to subtle off-by-one-frame errors if you're not careful, so be cautious about using OnChange on properties you also bind state to. That's everything you need to know about connecting properties with state - it's a simple concept, but fundamental to creating dynamic and interactive UIs. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"ExampleGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = Computed ( function () return \"There are \" .. numPlayers : get () .. \" online.\" end ) } }","title":"Deferred Updates"},{"location":"tutorials/fundamentals/computations/","text":"Usually, we don't use state as-is in our UI; we normally process it first. Let's learn how to perform computations on our state. Required code 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local numPlayers = State ( 5 ) The Computation Problem \u00b6 In UI development, lots of values are computed based on other values. For example, you might compute a message based on the number of players online: local numPlayers = 5 local message = \"There are \" .. numPlayers .. \" players online.\" However, there's a problem - when numPlayers changes, we have to manually re-calculate the message value ourselves. If you don't, then the message will show the wrong amount of players - an issue known as 'data desynchronisation'. Computed Objects \u00b6 To solve this problem, Fusion introduces a second kind of object - 'computed objects' . Instead of storing a fixed value, they run a computation. Think of it like a spreadsheet, where you can type in an equation that uses other values. To use computed objects, we first need to import the Computed constructor: 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed Now, we can create a computed object by calling the constructor. We pass in our computation as a function: 7 8 9 10 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) At any time, you can get the computed value with the :get() method: Lua 7 8 9 10 11 12 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) Expected output There are 5 players online. Now for the magic - whenever you use a state object as part of your computation, the computed object will update when the state object changes: Lua 7 8 9 10 11 12 13 14 15 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) numPlayers : set ( 12 ) print ( message : get ()) Expected output There are 5 players online. There are 12 players online. This solves our previous 'data desynchronisation' issue - we don't have to manually recalculate the message. Instead, Fusion handles it for us, because we're storing our state in Fusion's objects. That's the basic idea of computed objects; they let you naturally define values in terms of other values. Danger - Yielding Code inside of a computed callback should never yield. While Fusion does not currently throw an error for this, there are plans to change this. Yielding in a callback may break a lot of Fusion code which depends on updates to your variables being instant, for example dependency management. It can also lead to internally inconsistent code. If you need to perform a web call when some state changes, consider using Compat(state):onChange() to bind a change listener, which is allowed to yield, and store the result of the web call in a state object for use elsewhere: local playerID = State ( 1670764 ) -- bad - this will break! local playerData = Computed ( function () return ReplicatedStorage . GetPlayerData : InvokeServer ( playerID : get ()) end ) -- better - this moves the yielding safely outside of any state objects -- make sure to load the data for the first time if that's important local playerData = State ( nil ) Compat ( playerData ): onChange ( function () playerData : set ( ReplicatedStorage . GetPlayerData : InvokeServer ( playerID : get ())) end ) In the future, there are plans to make yielding code easier to work with. See this issue for more details. Danger - Using non-state objects Stick to using state objects and computed objects inside your computations. Fusion can detect when you use these objects and listen for changes. Fusion can't automatically detect changes when you use 'normal' variables: local theVariable = \"Hello\" local badValue = Computed ( function () -- don't do this! use state objects or computed objects in here return \"Say \" .. theVariable end ) print ( badValue : get ()) -- prints 'Say Hello' theVariable = \"World\" print ( badValue : get ()) -- still prints 'Say Hello' - that's a problem! By using a state object here, Fusion can correctly update the computed object, because it knows we used the state object: local theVariable = State ( \"Hello\" ) local goodValue = Computed ( function () -- this is much better - Fusion can detect we used this state object! return \"Say \" .. theVariable : get () end ) print ( goodValue : get ()) -- prints 'Say Hello' theVariable : set ( \"World\" ) print ( goodValue : get ()) -- prints 'Say World' This also applies to any functions that change on their own, like os.clock() . If you need to use them, store values from the function in a state object, and update the value of that object as often as required. Now, we've covered everything we need to know about Fusion's basic state tools. Using computed objects and state objects together, you can easily store and compute values while avoiding data desynchronisation bugs. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) numPlayers : set ( 12 ) print ( message : get ())","title":"Computations"},{"location":"tutorials/fundamentals/computations/#the-computation-problem","text":"In UI development, lots of values are computed based on other values. For example, you might compute a message based on the number of players online: local numPlayers = 5 local message = \"There are \" .. numPlayers .. \" players online.\" However, there's a problem - when numPlayers changes, we have to manually re-calculate the message value ourselves. If you don't, then the message will show the wrong amount of players - an issue known as 'data desynchronisation'.","title":"The Computation Problem"},{"location":"tutorials/fundamentals/computations/#computed-objects","text":"To solve this problem, Fusion introduces a second kind of object - 'computed objects' . Instead of storing a fixed value, they run a computation. Think of it like a spreadsheet, where you can type in an equation that uses other values. To use computed objects, we first need to import the Computed constructor: 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed Now, we can create a computed object by calling the constructor. We pass in our computation as a function: 7 8 9 10 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) At any time, you can get the computed value with the :get() method: Lua 7 8 9 10 11 12 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) Expected output There are 5 players online. Now for the magic - whenever you use a state object as part of your computation, the computed object will update when the state object changes: Lua 7 8 9 10 11 12 13 14 15 local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) numPlayers : set ( 12 ) print ( message : get ()) Expected output There are 5 players online. There are 12 players online. This solves our previous 'data desynchronisation' issue - we don't have to manually recalculate the message. Instead, Fusion handles it for us, because we're storing our state in Fusion's objects. That's the basic idea of computed objects; they let you naturally define values in terms of other values. Danger - Yielding Code inside of a computed callback should never yield. While Fusion does not currently throw an error for this, there are plans to change this. Yielding in a callback may break a lot of Fusion code which depends on updates to your variables being instant, for example dependency management. It can also lead to internally inconsistent code. If you need to perform a web call when some state changes, consider using Compat(state):onChange() to bind a change listener, which is allowed to yield, and store the result of the web call in a state object for use elsewhere: local playerID = State ( 1670764 ) -- bad - this will break! local playerData = Computed ( function () return ReplicatedStorage . GetPlayerData : InvokeServer ( playerID : get ()) end ) -- better - this moves the yielding safely outside of any state objects -- make sure to load the data for the first time if that's important local playerData = State ( nil ) Compat ( playerData ): onChange ( function () playerData : set ( ReplicatedStorage . GetPlayerData : InvokeServer ( playerID : get ())) end ) In the future, there are plans to make yielding code easier to work with. See this issue for more details. Danger - Using non-state objects Stick to using state objects and computed objects inside your computations. Fusion can detect when you use these objects and listen for changes. Fusion can't automatically detect changes when you use 'normal' variables: local theVariable = \"Hello\" local badValue = Computed ( function () -- don't do this! use state objects or computed objects in here return \"Say \" .. theVariable end ) print ( badValue : get ()) -- prints 'Say Hello' theVariable = \"World\" print ( badValue : get ()) -- still prints 'Say Hello' - that's a problem! By using a state object here, Fusion can correctly update the computed object, because it knows we used the state object: local theVariable = State ( \"Hello\" ) local goodValue = Computed ( function () -- this is much better - Fusion can detect we used this state object! return \"Say \" .. theVariable : get () end ) print ( goodValue : get ()) -- prints 'Say Hello' theVariable : set ( \"World\" ) print ( goodValue : get ()) -- prints 'Say World' This also applies to any functions that change on their own, like os.clock() . If you need to use them, store values from the function in a state object, and update the value of that object as often as required. Now, we've covered everything we need to know about Fusion's basic state tools. Using computed objects and state objects together, you can easily store and compute values while avoiding data desynchronisation bugs. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local numPlayers = State ( 5 ) local message = Computed ( function () return \"There are \" .. numPlayers : get () .. \" players online.\" end ) print ( message : get ()) numPlayers : set ( 12 ) print ( message : get ())","title":"Computed Objects"},{"location":"tutorials/fundamentals/creating-ui/","text":"Now that we have Fusion up and running, let's learn how to create instances from a script quickly and neatly. Required code 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Instances from Code \u00b6 In Fusion, you create all of your UI instances from code. That might sound counterproductive, but it will soon allow you to easily reuse your UI components and leverage powerful tools for connecting your UI and game scripts together. To make the experience more pleasant, Fusion introduces an alternative to Instance.new which lets you construct entire instances in one go - called the New function. Here's an example code snippet using New - you can compare it to Instance.new : New local myPart = New \"Part\" { Parent = workspace , Position = Vector3 . new ( 1 , 2 , 3 ), BrickColor = BrickColor . new ( \"Bright green\" ), Size = Vector3 . new ( 2 , 1 , 4 ) } Instance.new local myPart = Instance . new ( \"Part\" ) myPart . Position = Vector3 . new ( 1 , 2 , 3 ) myPart . BrickColor = BrickColor . new ( \"Bright green\" ) myPart . Size = Vector3 . new ( 2 , 1 , 4 ) myPart . Parent = workspace Note You don't need parentheses () for New - just type the class name and properties like we did above. In the above code snippet, the New function: creates a new part gives it a position, size and colour parents it to the workspace returns the part, so it can be stored in myPart The New function has many more features built in, which you'll use later, but for now we'll just use it to set properties. Making A ScreenGui \u00b6 Let's use the New function to create a ScreenGui. We're going to put it in our PlayerGui, so we need to import the Players service: 1 2 3 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) We'll also need to import New from Fusion: 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New Now, we can use the New function like we did in the snippet above. We want to create a ScreenGui with a name of 'MyFirstGui' parented to our PlayerGui. The following code snippet does all of this for us: 1 2 3 4 5 6 7 8 9 10 11 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" } If you press 'Play', you should see that a ScreenGui has appeared in your PlayerGui, with all of the properties we've set: Hopefully you're getting comfortable with this syntax - we'll expand on it in the next section. Tip Fusion automatically applies some 'sensible default' properties for you, so you don't have to specify them. Here, ZIndexBehavior will default to 'false' and ResetOnSpawn defaults to false . You can see a list of all default properties here. Adding a Child \u00b6 Let's now add a TextLabel with a message and parent it to our ScreenGui. To help with this, the New function lets us add children directly to our instance. In order to use this feature, we first need to import Children from Fusion: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children Now, we can make any instance a child of our ScreenGui - just pass it in using [ Children ] as the key. For example, here we're creating our TextLabel, and adding it as a child: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" } } If you press 'Play' now, you should see a TextLabel in the centre of your screen: Multiple Children \u00b6 You can add more than one instance - Children supports arrays of instances. If we wanted multiple TextLabels, we can create an array to hold our children: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" } } } Now, we can add another TextLabel to the array, and it will also be parented: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Two is better than one!\" } } } If you press 'Play', you should see both TextLabels appear: Congratulations - you've now learned how to create simple instances with Fusion! Over the course of the next few tutorials, you'll see this syntax being used a lot, so you'll have some time to get used to it. It's important to understand the basics of the New function, as it's used throughout almost all Fusion code. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Two is better than one!\" } } }","title":"Creating UI"},{"location":"tutorials/fundamentals/creating-ui/#instances-from-code","text":"In Fusion, you create all of your UI instances from code. That might sound counterproductive, but it will soon allow you to easily reuse your UI components and leverage powerful tools for connecting your UI and game scripts together. To make the experience more pleasant, Fusion introduces an alternative to Instance.new which lets you construct entire instances in one go - called the New function. Here's an example code snippet using New - you can compare it to Instance.new : New local myPart = New \"Part\" { Parent = workspace , Position = Vector3 . new ( 1 , 2 , 3 ), BrickColor = BrickColor . new ( \"Bright green\" ), Size = Vector3 . new ( 2 , 1 , 4 ) } Instance.new local myPart = Instance . new ( \"Part\" ) myPart . Position = Vector3 . new ( 1 , 2 , 3 ) myPart . BrickColor = BrickColor . new ( \"Bright green\" ) myPart . Size = Vector3 . new ( 2 , 1 , 4 ) myPart . Parent = workspace Note You don't need parentheses () for New - just type the class name and properties like we did above. In the above code snippet, the New function: creates a new part gives it a position, size and colour parents it to the workspace returns the part, so it can be stored in myPart The New function has many more features built in, which you'll use later, but for now we'll just use it to set properties.","title":"Instances from Code"},{"location":"tutorials/fundamentals/creating-ui/#making-a-screengui","text":"Let's use the New function to create a ScreenGui. We're going to put it in our PlayerGui, so we need to import the Players service: 1 2 3 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) We'll also need to import New from Fusion: 1 2 3 4 5 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New Now, we can use the New function like we did in the snippet above. We want to create a ScreenGui with a name of 'MyFirstGui' parented to our PlayerGui. The following code snippet does all of this for us: 1 2 3 4 5 6 7 8 9 10 11 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" } If you press 'Play', you should see that a ScreenGui has appeared in your PlayerGui, with all of the properties we've set: Hopefully you're getting comfortable with this syntax - we'll expand on it in the next section. Tip Fusion automatically applies some 'sensible default' properties for you, so you don't have to specify them. Here, ZIndexBehavior will default to 'false' and ResetOnSpawn defaults to false . You can see a list of all default properties here.","title":"Making A ScreenGui"},{"location":"tutorials/fundamentals/creating-ui/#adding-a-child","text":"Let's now add a TextLabel with a message and parent it to our ScreenGui. To help with this, the New function lets us add children directly to our instance. In order to use this feature, we first need to import Children from Fusion: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children Now, we can make any instance a child of our ScreenGui - just pass it in using [ Children ] as the key. For example, here we're creating our TextLabel, and adding it as a child: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" } } If you press 'Play' now, you should see a TextLabel in the centre of your screen:","title":"Adding a Child"},{"location":"tutorials/fundamentals/creating-ui/#multiple-children","text":"You can add more than one instance - Children supports arrays of instances. If we wanted multiple TextLabels, we can create an array to hold our children: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" } } } Now, we can add another TextLabel to the array, and it will also be parented: 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Two is better than one!\" } } } If you press 'Play', you should see both TextLabels appear: Congratulations - you've now learned how to create simple instances with Fusion! Over the course of the next few tutorials, you'll see this syntax being used a lot, so you'll have some time to get used to it. It's important to understand the basics of the New function, as it's used throughout almost all Fusion code. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextLabel\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" }, New \"TextLabel\" { Position = UDim2 . new ( .5 , 0 , .5 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Two is better than one!\" } } }","title":"Multiple Children"},{"location":"tutorials/fundamentals/handling-events/","text":"Now that we can create instances, let's learn how to handle events and property changes. Required code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Click me!\" }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false } } } Connecting to Events \u00b6 Inside the code from above, you'll notice a TextButton. Let's try to connect to it's Activated event to detect mouse clicks. To help with this, New allows us to add event handlers on our instance directly. In order to use this feature, we need to import OnEvent from Fusion: 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent Now you can pass in event handling functions by using [ OnEvent \"EventName\" ] as the key. As an example, here we're connecting a function to our TextButton's Activated event: 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" , [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), This works just like a regular :Connect() - you'll recieve all the arguments from the event. Here, we're just printing them out for demonstration purposes. If you press 'Play' and click the button a few times, you should see something like this in the output: That's all there is to event handling! Fusion will manage the event connections for you automatically. Responding to Change \u00b6 In addition to regular events, you can listen to property change events (the events returned by GetPropertyChangedSignal ). In order to use property change events, you'll need to import OnChange : 1 2 3 4 5 6 7 8 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange Now you can pass in functions using [ OnChange \"PropertyName\" ] as the key. When the property is changed, your function will be called with the new value as the only argument. To demonstrate this, here we're printing the text in our TextBox whenever it changes: 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } } Now, if you press 'Play' and start typing into the TextBox, you should see the TextBox's contents being printed to the output for each character you type: With that, you've covered everything there is to know about event and property change handlers! In later tutorials, this will be useful for responding to user input. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Click me!\" , [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } }","title":"Handling Events"},{"location":"tutorials/fundamentals/handling-events/#connecting-to-events","text":"Inside the code from above, you'll notice a TextButton. Let's try to connect to it's Activated event to detect mouse clicks. To help with this, New allows us to add event handlers on our instance directly. In order to use this feature, we need to import OnEvent from Fusion: 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent Now you can pass in event handling functions by using [ OnEvent \"EventName\" ] as the key. As an example, here we're connecting a function to our TextButton's Activated event: 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Fusion is fun :)\" , [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), This works just like a regular :Connect() - you'll recieve all the arguments from the event. Here, we're just printing them out for demonstration purposes. If you press 'Play' and click the button a few times, you should see something like this in the output: That's all there is to event handling! Fusion will manage the event connections for you automatically.","title":"Connecting to Events"},{"location":"tutorials/fundamentals/handling-events/#responding-to-change","text":"In addition to regular events, you can listen to property change events (the events returned by GetPropertyChangedSignal ). In order to use property change events, you'll need to import OnChange : 1 2 3 4 5 6 7 8 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange Now you can pass in functions using [ OnChange \"PropertyName\" ] as the key. When the property is changed, your function will be called with the new value as the only argument. To demonstrate this, here we're printing the text in our TextBox whenever it changes: 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } } Now, if you press 'Play' and start typing into the TextBox, you should see the TextBox's contents being printed to the output for each character you type: With that, you've covered everything there is to know about event and property change handlers! In later tutorials, this will be useful for responding to user input. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local OnChange = Fusion . OnChange local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"MyFirstGui\" , ResetOnSpawn = false , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Click me!\" , [ OnEvent \"Activated\" ] = function (...) print ( \"Clicked!\" , ...) end }, New \"TextBox\" { Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"\" , ClearTextOnFocus = false , [ OnChange \"Text\" ] = function ( newText ) print ( newText ) end } } }","title":"Responding to Change"},{"location":"tutorials/fundamentals/project-1/","text":"Under construction This page is under construction - information may be incomplete or missing. Using everything we've learned so far, let's build a complete UI to see how Fusion's basic tools work together in a real project. Required code 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local State = Fusion . State local Computed = Fusion . Computed Building The UI \u00b6 We'll be creating a button which shows how many times you've clicked it - this is often used as an introductory UI example for many libraries and frameworks because it involves UI, event handling and state management together. We'll start by creating a ScreenGui to contain our button: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local State = Fusion . State local Computed = Fusion . Computed local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" } Next, we'll create a TextButton we can click, and a message TextLabel which will eventually show how many clicks we've performed: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"Click me!\" }, New \"TextLabel\" { Name = \"Message\" , Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 255 , 255 , 255 ), Text = \"Placeholder message...\" } } } With just these three instances, we have enough to work with for the rest of this tutorial. Running the above script gives us this: Adding State \u00b6 Now, let's add some state to make our UI dynamic. Let's start with a state object to store the number of clicks: 12 13 14 15 16 17 18 19 20 local numClicks = State ( 0 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { Now, we can replace the placeholder text with some computed state, to turn our number of clicks into a fully-formed message: 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Text = \"Click me!\" }, New \"TextLabel\" { Name = \"Message\" , Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 255 , 255 , 255 ), Text = Computed ( function () return \"You clicked \" .. numClicks : get () .. \" times.\" end ) } } } You'll now notice the message's text reflects the number of clicks stored in numClicks : Listening for Clicks \u00b6 Now that we have our UI in place and it's working with our state, we just need to increment the number stored in numClicks when we click the button. To start, let's add an OnEvent handler for the button's Activated event. This will run when we click the button: [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"Click me!\" , [ OnEvent \"Activated\" ] = function () -- the button was clicked! -- TODO: increment state end }, New \"TextLabel\" { Then, to increment the state, we can :get() the number of clicks, add one, then :set() it to the new value: [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"Click me!\" , [ OnEvent \"Activated\" ] = function () -- the button was clicked! numClicks : set ( numClicks : get () + 1 ) end }, New \"TextLabel\" { That's everything - try clicking the button, and watch the message change in response: If you've managed to follow along, congratulations - you should now have a good understanding of Fusion's fundamental concepts! With just these tools alone, you'll be able to build almost anything you can think of. However, Fusion still has more tools available to make your code simpler and easier to manage - we'll cover this in 'Further Basics' .","title":"Project 1: Counting Clicks"},{"location":"tutorials/fundamentals/project-1/#building-the-ui","text":"We'll be creating a button which shows how many times you've clicked it - this is often used as an introductory UI example for many libraries and frameworks because it involves UI, event handling and state management together. We'll start by creating a ScreenGui to contain our button: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New local Children = Fusion . Children local OnEvent = Fusion . OnEvent local State = Fusion . State local Computed = Fusion . Computed local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" } Next, we'll create a TextButton we can click, and a message TextLabel which will eventually show how many clicks we've performed: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"Click me!\" }, New \"TextLabel\" { Name = \"Message\" , Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 255 , 255 , 255 ), Text = \"Placeholder message...\" } } } With just these three instances, we have enough to work with for the rest of this tutorial. Running the above script gives us this:","title":"Building The UI"},{"location":"tutorials/fundamentals/project-1/#adding-state","text":"Now, let's add some state to make our UI dynamic. Let's start with a state object to store the number of clicks: 12 13 14 15 16 17 18 19 20 local numClicks = State ( 0 ) local gui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Name = \"CountingGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { Now, we can replace the placeholder text with some computed state, to turn our number of clicks into a fully-formed message: 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Text = \"Click me!\" }, New \"TextLabel\" { Name = \"Message\" , Position = UDim2 . new ( 0.5 , 0 , 0.5 , 100 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 255 , 255 , 255 ), Text = Computed ( function () return \"You clicked \" .. numClicks : get () .. \" times.\" end ) } } } You'll now notice the message's text reflects the number of clicks stored in numClicks :","title":"Adding State"},{"location":"tutorials/fundamentals/project-1/#listening-for-clicks","text":"Now that we have our UI in place and it's working with our state, we just need to increment the number stored in numClicks when we click the button. To start, let's add an OnEvent handler for the button's Activated event. This will run when we click the button: [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"Click me!\" , [ OnEvent \"Activated\" ] = function () -- the button was clicked! -- TODO: increment state end }, New \"TextLabel\" { Then, to increment the state, we can :get() the number of clicks, add one, then :set() it to the new value: [ Children ] = { New \"TextButton\" { Name = \"ClickButton\" , Position = UDim2 . fromScale ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), AnchorPoint = Vector2 . new ( .5 , .5 ), BackgroundColor3 = Color3 . fromRGB ( 85 , 255 , 0 ), Text = \"Click me!\" , [ OnEvent \"Activated\" ] = function () -- the button was clicked! numClicks : set ( numClicks : get () + 1 ) end }, New \"TextLabel\" { That's everything - try clicking the button, and watch the message change in response: If you've managed to follow along, congratulations - you should now have a good understanding of Fusion's fundamental concepts! With just these tools alone, you'll be able to build almost anything you can think of. However, Fusion still has more tools available to make your code simpler and easier to manage - we'll cover this in 'Further Basics' .","title":"Listening for Clicks"},{"location":"tutorials/fundamentals/storing-state/","text":"Our UIs may use some data - called 'state' - to change how it appears. Let's learn how to store this data in Fusion. Required code 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) What is State? \u00b6 State is (simplistically) the variables that determine what your UI looks like at a given point in time. A simple example of this is a health bar. To know what the health bar looks like at any point in time, we need to know two things: the current health to show the max health of the player These two variables are therefore known as the 'state' of the health bar. To show the health bar on the screen, we need to use the values of these variables. Storing State \u00b6 Fusion provides some nice tools for manipulating state and using it in our UI, but in order to use those tools, we need to store our state in 'state objects' - simple OOP objects that store a single value. To use state objects, we first need to import the State constructor: 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State Now, we can create a state object by calling the constructor. If you pass in a value, it'll be stored inside the state object: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) At any time, you can get the currently stored value with the :get() method: Lua 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) Expected output The value is: Hello You can also set the value by calling :set() with a new value: Lua 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ()) Expected output The value is: Hello The new value is: World With that, you should have the basic idea of state objects - they're kind of like variables, but in object form. These objects will later act like 'inputs' into Fusion's other state management tools. Finished code 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ())","title":"Storing State"},{"location":"tutorials/fundamentals/storing-state/#what-is-state","text":"State is (simplistically) the variables that determine what your UI looks like at a given point in time. A simple example of this is a health bar. To know what the health bar looks like at any point in time, we need to know two things: the current health to show the max health of the player These two variables are therefore known as the 'state' of the health bar. To show the health bar on the screen, we need to use the values of these variables.","title":"What is State?"},{"location":"tutorials/fundamentals/storing-state/#storing-state","text":"Fusion provides some nice tools for manipulating state and using it in our UI, but in order to use those tools, we need to store our state in 'state objects' - simple OOP objects that store a single value. To use state objects, we first need to import the State constructor: 1 2 3 4 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State Now, we can create a state object by calling the constructor. If you pass in a value, it'll be stored inside the state object: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) At any time, you can get the currently stored value with the :get() method: Lua 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) Expected output The value is: Hello You can also set the value by calling :set() with a new value: Lua 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ()) Expected output The value is: Hello The new value is: World With that, you should have the basic idea of state objects - they're kind of like variables, but in object form. These objects will later act like 'inputs' into Fusion's other state management tools. Finished code 1 2 3 4 5 6 7 8 9 10 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local message = State ( \"Hello\" ) print ( \"The value is:\" , message : get ()) message : set ( \"World\" ) print ( \"The new value is:\" , message : get ())","title":"Storing State"},{"location":"tutorials/further-basics/arrays-and-lists/","text":"Efficiently working with tables can be difficult. Let's learn about the tools Fusion provides to make working with arrays and tables easier. Required code 1 2 3 4 5 6 7 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local numbers = State ({ 1 , 2 , 3 , 4 , 5 }) Computed Arrays \u00b6 Suppose we have a state object storing an array of numbers, and we'd like to create a computed object which doubles each number. You could achieve this with a for-pairs loop: 7 8 9 10 11 12 13 14 15 16 17 local numbers = State ({ 1 , 2 , 3 , 4 , 5 }) local doubledNumbers = Computed ( function () local doubled = {} for index , number in pairs ( numbers : get ()) do doubled [ index ] = number * 2 end return doubled end ) print ( doubledNumbers : get ()) --> {2, 4, 6, 8, 10} While this works, it's pretty verbose. To make this code simpler, Fusion has a special computed object designed for processing tables, known as ComputedPairs . To use it, we need to import ComputedPairs from Fusion: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local ComputedPairs = Fusion . ComputedPairs ComputedPairs acts similarly to the for-pairs loop we wrote above - it goes through each entry of the array, processes the value, and saves it into the new array: 8 9 10 11 12 13 14 local numbers = State ({ 1 , 2 , 3 , 4 , 5 }) local doubledNumbers = ComputedPairs ( numbers , function ( index , number ) return number * 2 end ) print ( doubledNumbers : get ()) --> {2, 4, 6, 8, 10} This can be used to process any kind of table, not just arrays. Notice how the keys stay the same, and the value is whatever you return: 8 9 10 11 12 13 14 local data = State ({ Blue = \"good\" , Green = \"bad\" }) local processedData = ComputedPairs ( data , function ( colour , word ) return colour .. \" is \" .. word end ) print ( processedData : get ()) --> {Blue = \"Blue is good\", Green = \"Green is bad\"} Cleaning Up Values \u00b6 Sometimes, you might use ComputedPairs to generate lists of instances, or other similar data types. When we're done with these, we need to destroy them. Conveniently, ComputedPairs already cleans up some types when they're removed from the output array: returned instances will be destroyed returned event connections will be disconnected returned functions will be run returned objects will have their :Destroy() or :destroy() methods called returned arrays will have their contents cleaned up This should cover most use cases by default. However, if you need to override this cleanup behaviour, you can pass in an optional destructor function as the second argument. It will be called any time a generated value is removed or overwritten, so you can clean it up: Lua 8 9 10 11 12 13 14 15 16 17 18 19 20 local names = State ({ \"John\" , \"Dave\" , \"Sebastian\" }) local greetings = ComputedPairs ( names , function ( index , name ) return \"Hello, \" .. name end , function ( greeting ) print ( \"Removed: \" .. greeting ) end ) names : set ({ \"John\" , \"Trey\" , \"Charlie\" }) Expected output Removed: Hello, Dave Removed: Hello, Sebastian Optimisation \u00b6 To improve performance, ComputedPairs doesn't recalculate a key if its value stays the same: Lua 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 local data = State ({ One = 1 , Two = 2 , Three = 3 }) print ( \"Creating processedData...\" ) local processedData = ComputedPairs ( data , function ( key , value ) print ( \" ...recalculating key: \" .. key ) return value * 2 end ) print ( \"Changing the values of some keys...\" ) data : set ({ One = 1 , Two = 100 , Three = 3 , Four = 4 }) Expected output Creating processedData... ...recalculating key: One ...recalculating key: Two ...recalculating key: Three Changing the values of some keys... ...recalculating key: Two ...recalculating key: Four Because the keys Two and Four have different values after the change, they're recalculated. However, One and Three have the same values, so they'll be reused instead: This is a simple rule which should work well for tables with 'stable keys' (keys that don't change as other values are added and removed). However, if you're working with 'unstable keys' (e.g. an array where values can move to different keys) then you can get unnecessary recalculations. In the following code, Yellow gets recalculated, because it moves to a different key: Lua 8 9 10 11 12 13 14 15 16 17 18 local data = State ({ \"Red\" , \"Green\" , \"Blue\" , \"Yellow\" }) print ( \"Creating processedData...\" ) local processedData = ComputedPairs ( data , function ( key , value ) print ( \" ...recalculating key: \" .. key .. \" value: \" .. value ) return value end ) print ( \"Removing Blue...\" ) data : set ({ \"Red\" , \"Green\" , \"Yellow\" }) Expected output Creating processedData... ...recalculating key: 1 value: Red ...recalculating key: 2 value: Green ...recalculating key: 3 value: Blue ...recalculating key: 4 value: Yellow Moving the values around... ...recalculating key: 3 value: Yellow You can see this more clearly in the following diagram - the value of key 3 was changed, so it triggered a recalculation: If the keys aren't needed, you can use your values as keys instead. This makes them stable, because they won't be affected by other insertions or removals: Lua 8 9 10 11 12 13 14 15 16 17 18 local data = State ({ Red = true , Green = true , Blue = true , Yellow = true }) print ( \"Creating processedData...\" ) local processedData = ComputedPairs ( data , function ( key ) print ( \" ...recalculating key: \" .. key ) return key end ) print ( \"Removing Blue...\" ) data : set ({ Red = true , Green = true , Yellow = true }) Expected output Creating processedData... ...recalculating key: Red ...recalculating key: Green ...recalculating key: Blue ...recalculating key: Yellow Removing Blue... Notice that, when we remove Blue , no other values are recalculated. This is ideal, and means we're not doing unnecessary processing: This is especially important when optimising 'heavy' arrays, for example long lists of instances. The less unnecessary recalculation, the better! With that, you should now have a basic idea of how to work with table state in Fusion. When you get used to this workflow, you can express your logic cleanly, and get great caching and cleanup behaviour for free. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local ComputedPairs = Fusion . ComputedPairs local data = State ({ Red = true , Green = true , Blue = true , Yellow = true }) print ( \"Creating processedData...\" ) local processedData = ComputedPairs ( data , function ( key ) print ( \" ...recalculating key: \" .. key ) return key end ) print ( \"Removing Blue...\" ) data : set ({ Red = true , Green = true , Yellow = true })","title":"Arrays and Lists"},{"location":"tutorials/further-basics/arrays-and-lists/#computed-arrays","text":"Suppose we have a state object storing an array of numbers, and we'd like to create a computed object which doubles each number. You could achieve this with a for-pairs loop: 7 8 9 10 11 12 13 14 15 16 17 local numbers = State ({ 1 , 2 , 3 , 4 , 5 }) local doubledNumbers = Computed ( function () local doubled = {} for index , number in pairs ( numbers : get ()) do doubled [ index ] = number * 2 end return doubled end ) print ( doubledNumbers : get ()) --> {2, 4, 6, 8, 10} While this works, it's pretty verbose. To make this code simpler, Fusion has a special computed object designed for processing tables, known as ComputedPairs . To use it, we need to import ComputedPairs from Fusion: 1 2 3 4 5 6 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local ComputedPairs = Fusion . ComputedPairs ComputedPairs acts similarly to the for-pairs loop we wrote above - it goes through each entry of the array, processes the value, and saves it into the new array: 8 9 10 11 12 13 14 local numbers = State ({ 1 , 2 , 3 , 4 , 5 }) local doubledNumbers = ComputedPairs ( numbers , function ( index , number ) return number * 2 end ) print ( doubledNumbers : get ()) --> {2, 4, 6, 8, 10} This can be used to process any kind of table, not just arrays. Notice how the keys stay the same, and the value is whatever you return: 8 9 10 11 12 13 14 local data = State ({ Blue = \"good\" , Green = \"bad\" }) local processedData = ComputedPairs ( data , function ( colour , word ) return colour .. \" is \" .. word end ) print ( processedData : get ()) --> {Blue = \"Blue is good\", Green = \"Green is bad\"}","title":"Computed Arrays"},{"location":"tutorials/further-basics/arrays-and-lists/#cleaning-up-values","text":"Sometimes, you might use ComputedPairs to generate lists of instances, or other similar data types. When we're done with these, we need to destroy them. Conveniently, ComputedPairs already cleans up some types when they're removed from the output array: returned instances will be destroyed returned event connections will be disconnected returned functions will be run returned objects will have their :Destroy() or :destroy() methods called returned arrays will have their contents cleaned up This should cover most use cases by default. However, if you need to override this cleanup behaviour, you can pass in an optional destructor function as the second argument. It will be called any time a generated value is removed or overwritten, so you can clean it up: Lua 8 9 10 11 12 13 14 15 16 17 18 19 20 local names = State ({ \"John\" , \"Dave\" , \"Sebastian\" }) local greetings = ComputedPairs ( names , function ( index , name ) return \"Hello, \" .. name end , function ( greeting ) print ( \"Removed: \" .. greeting ) end ) names : set ({ \"John\" , \"Trey\" , \"Charlie\" }) Expected output Removed: Hello, Dave Removed: Hello, Sebastian","title":"Cleaning Up Values"},{"location":"tutorials/further-basics/arrays-and-lists/#optimisation","text":"To improve performance, ComputedPairs doesn't recalculate a key if its value stays the same: Lua 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 local data = State ({ One = 1 , Two = 2 , Three = 3 }) print ( \"Creating processedData...\" ) local processedData = ComputedPairs ( data , function ( key , value ) print ( \" ...recalculating key: \" .. key ) return value * 2 end ) print ( \"Changing the values of some keys...\" ) data : set ({ One = 1 , Two = 100 , Three = 3 , Four = 4 }) Expected output Creating processedData... ...recalculating key: One ...recalculating key: Two ...recalculating key: Three Changing the values of some keys... ...recalculating key: Two ...recalculating key: Four Because the keys Two and Four have different values after the change, they're recalculated. However, One and Three have the same values, so they'll be reused instead: This is a simple rule which should work well for tables with 'stable keys' (keys that don't change as other values are added and removed). However, if you're working with 'unstable keys' (e.g. an array where values can move to different keys) then you can get unnecessary recalculations. In the following code, Yellow gets recalculated, because it moves to a different key: Lua 8 9 10 11 12 13 14 15 16 17 18 local data = State ({ \"Red\" , \"Green\" , \"Blue\" , \"Yellow\" }) print ( \"Creating processedData...\" ) local processedData = ComputedPairs ( data , function ( key , value ) print ( \" ...recalculating key: \" .. key .. \" value: \" .. value ) return value end ) print ( \"Removing Blue...\" ) data : set ({ \"Red\" , \"Green\" , \"Yellow\" }) Expected output Creating processedData... ...recalculating key: 1 value: Red ...recalculating key: 2 value: Green ...recalculating key: 3 value: Blue ...recalculating key: 4 value: Yellow Moving the values around... ...recalculating key: 3 value: Yellow You can see this more clearly in the following diagram - the value of key 3 was changed, so it triggered a recalculation: If the keys aren't needed, you can use your values as keys instead. This makes them stable, because they won't be affected by other insertions or removals: Lua 8 9 10 11 12 13 14 15 16 17 18 local data = State ({ Red = true , Green = true , Blue = true , Yellow = true }) print ( \"Creating processedData...\" ) local processedData = ComputedPairs ( data , function ( key ) print ( \" ...recalculating key: \" .. key ) return key end ) print ( \"Removing Blue...\" ) data : set ({ Red = true , Green = true , Yellow = true }) Expected output Creating processedData... ...recalculating key: Red ...recalculating key: Green ...recalculating key: Blue ...recalculating key: Yellow Removing Blue... Notice that, when we remove Blue , no other values are recalculated. This is ideal, and means we're not doing unnecessary processing: This is especially important when optimising 'heavy' arrays, for example long lists of instances. The less unnecessary recalculation, the better! With that, you should now have a basic idea of how to work with table state in Fusion. When you get used to this workflow, you can express your logic cleanly, and get great caching and cleanup behaviour for free. Finished code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) local State = Fusion . State local Computed = Fusion . Computed local ComputedPairs = Fusion . ComputedPairs local data = State ({ Red = true , Green = true , Blue = true , Yellow = true }) print ( \"Creating processedData...\" ) local processedData = ComputedPairs ( data , function ( key ) print ( \" ...recalculating key: \" .. key ) return key end ) print ( \"Removing Blue...\" ) data : set ({ Red = true , Green = true , Yellow = true })","title":"Optimisation"},{"location":"tutorials/further-basics/compatibility/","text":"Under construction This page is under construction - information may be incomplete or missing.","title":"Compatibility"},{"location":"tutorials/further-basics/components/","text":"It's often a good idea to split our UI into reusable parts, known as 'components'. Let's learn how you can create these with Fusion. What are Components? \u00b6 When we think about UIs as humans, we typically think of them in terms of reusable 'blocks' of UI. For example, you may divide up the following interface into these 'blocks': In UI design and development, these are widely known as 'components'. Components are useful, because we only need to define what each component looks like generally . We can then apply that look to every component across our UI. You can even provide properties, like some text to insert, or whether to show an icon: Building our UI by assembling components (rather than creating every instance manually) will help us to reuse and organise our UI code, and makes it easier to read and edit. Reusing UI \u00b6 When we want to reuse a bit of code, we often put it in a function. We can then use that code snippet in multiple places, optionally providing arguments to tweak how it runs. This lines up with what we need 'components' to do - we want to be able to reuse parts of our UI in multiple places, optionally providing properties to tweak how it looks. That's why, in Fusion, components are just functions. They take in a table of properties, create some UI, and return it: local function Greeting ( props ) return New \"TextLabel\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 0 ), TextColor3 = Color3 . new ( 0 , 0 , 1 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = props . Message } end We can now call the Greeting function to get a copy of that UI with any message we'd like: local greeting1 = Greeting { Message = \"Hello!\" } local greeting2 = Greeting { Message = \"Hey :)\" } Note If you're using a single props argument (like we did above), you don't need any parentheses () when you call the function with a table! We can also blend components into our other Fusion code easily: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = Greeting { Message = \"What's up? B)\" } } This makes components a powerful tool for creating tidy, reusable UI code inside Fusion. For the rest of this tutorial, let's look at a few common scripting patterns you can use with components to make them even more useful. Passing in Children \u00b6 Sometimes, we want to create components that can hold children. For example, take a look at this component, which arranges some children into a scrolling grid: local function Gallery ( props ) return New \"ScrollingFrame\" { Position = props . Position , Size = props . Size , AnchorPoint = props . AnchorPoint , [ Children ] = { New \"UIGridLayout\" { CellPadding = UDim2 . fromOffset ( 4 , 4 ), CellSize = UDim2 . fromOffset ( 100 , 100 ) }, -- TODO: put some children here? } } end Suppose we'd like users to be able to pass in children to show up in the grid: local gallery = Gallery { Position = UDim2 . fromScale ( .5 , .5 ) Size = UDim2 . fromOffset ( 400 , 300 ), AnchorPoint = Vector2 . new ( .5 , .5 ), [ Children ] = { New \"ImageLabel\" { ... }, New \"ImageLabel\" { ... }, New \"ImageLabel\" { ... } } } We can access those children in our function using props [ Children ] . Since the New function lets us pass in arrays of children, we can just include it directly in our code like so: local function Gallery ( props ) return New \"ScrollingFrame\" { Position = props . Position , Size = props . Size , AnchorPoint = props . AnchorPoint , [ Children ] = { New \"UIGridLayout\" { CellPadding = UDim2 . fromOffset ( 4 , 4 ), CellSize = UDim2 . fromOffset ( 100 , 100 ) }, props [ Children ] } } end That's all there is to it! Just keep in mind that [ Children ] is still a property like any other, so if you're processing the children, it might be good to do some type checking first. Multiple Instances \u00b6 In some specific circumstances, you may want to return more than one instance from a component. You shouldn't return multiple values from a component directly. Because of how Lua works, this can introduce subtle bugs in your code: local function ManyThings ( props ) -- don't do this! -- you should only return one value from a component return New \"TextLabel\" {...}, New \"ImageButton\" {...}, New \"Frame\" {...} end local gui1 = New \"ScreenGui\" { -- this will only parent the TextLabel! [ Children ] = ManyThings {} } local gui2 = New \"ScreenGui\" { [ Children ] = { New \"TextLabel\" {...}, -- this is also broken ManyThings {}, New \"TextLabel\" {...} } } A better way to do this is to return an array of instances. This means you only return a single value - the array. This gets around the subtle bugs that normally occur when dealing with multiple return values. Since [ Children ] supports arrays of children, all our instances are now parented as expected: local function ManyThings ( props ) -- using an array ensures we only return one value return { New \"TextLabel\" {...}, New \"ImageButton\" {...}, New \"Frame\" {...} } end local gui1 = New \"ScreenGui\" { -- this now works! [ Children ] = ManyThings {} } local gui2 = New \"ScreenGui\" { [ Children ] = { New \"TextLabel\" {...}, -- this also now works! ManyThings {}, New \"TextLabel\" {...} } } Tip If you're coming from other UI libraries or frameworks, you may have heard of this concept referred to as 'fragments'. In Fusion, fragments are just plain arrays of children rather than a special kind of object. Callbacks \u00b6 For some components (e.g. buttons or text boxes), some code might need to run in response to events like clicks or typing. You can use callbacks to achieve this. Consider this Button component as an example. Notice we're using props.OnClick with [ OnEvent \"Activated\" ] : local function Button ( props ) return New \"TextButton\" { Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , BackgroundColor3 = Color3 . new ( 0 , 0.4 , 1 ), TextColor3 = Color3 . new ( 1 , 1 , 1 ), Text = props . Message , [ OnEvent \"Activated\" ] = props . OnClick } end This means that anyone using the Button component can provide a callback function, which will then be run when the button is clicked: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { Button { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Message = \"Click me!\" , OnClick = function () -- this callback function will be passed into OnEvent, so it'll -- run when the button is clicked print ( \"The button was clicked!\" ) end }, } } This isn't just limited to event handlers, either - any time you want to let the caller provide some code, callbacks are a great option. State \u00b6 Because components are functions, we can do more than just creating instances. You can also store state inside them! Let's make a 'toggle button' component to demonstrate this. When we click it, it should toggle on and off. Here's some basic code to get started - we just need to add some state to this: local function ToggleButton ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = props . message , [ OnEvent \"Activated\" ] = function () -- TODO: toggle the button! end } end Firstly, let's create a state object to store whether the button is currently toggled on or off: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () -- TODO: toggle the button! end } end Next, we can toggle the stored value in our event handler: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () isButtonOn : set ( not isButtonOn : get ()) end } end Finally, we can make the background colour show whether the button is toggled on or off, using some computed state: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Computed ( function () if isButtonOn : get () then return Color3 . new ( 0 , 1 , 0 ) -- green when toggled on else return Color3 . new ( 1 , 0 , 0 ) -- red when toggled off end end ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () isButtonOn : set ( not isButtonOn : get ()) end } end With just this code, we've made our toggle button fully functional! Again, this is a regular Lua function, so nothing fancy is going on behind the scenes. Just like before, we can now include our toggle button in our UI easily: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"UIListLayout\" { Padding = UDim . new ( 0 , 4 ) }, ToggleButton { message = \"Click me!\" }, ToggleButton { message = \"Also, click me!\" }, ToggleButton { message = \"Each button is independent :)\" } } } Because we create a new button each time we call the function, each button keeps it's own state and functions independently.","title":"Components"},{"location":"tutorials/further-basics/components/#what-are-components","text":"When we think about UIs as humans, we typically think of them in terms of reusable 'blocks' of UI. For example, you may divide up the following interface into these 'blocks': In UI design and development, these are widely known as 'components'. Components are useful, because we only need to define what each component looks like generally . We can then apply that look to every component across our UI. You can even provide properties, like some text to insert, or whether to show an icon: Building our UI by assembling components (rather than creating every instance manually) will help us to reuse and organise our UI code, and makes it easier to read and edit.","title":"What are Components?"},{"location":"tutorials/further-basics/components/#reusing-ui","text":"When we want to reuse a bit of code, we often put it in a function. We can then use that code snippet in multiple places, optionally providing arguments to tweak how it runs. This lines up with what we need 'components' to do - we want to be able to reuse parts of our UI in multiple places, optionally providing properties to tweak how it looks. That's why, in Fusion, components are just functions. They take in a table of properties, create some UI, and return it: local function Greeting ( props ) return New \"TextLabel\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 0 ), TextColor3 = Color3 . new ( 0 , 0 , 1 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = props . Message } end We can now call the Greeting function to get a copy of that UI with any message we'd like: local greeting1 = Greeting { Message = \"Hello!\" } local greeting2 = Greeting { Message = \"Hey :)\" } Note If you're using a single props argument (like we did above), you don't need any parentheses () when you call the function with a table! We can also blend components into our other Fusion code easily: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = Greeting { Message = \"What's up? B)\" } } This makes components a powerful tool for creating tidy, reusable UI code inside Fusion. For the rest of this tutorial, let's look at a few common scripting patterns you can use with components to make them even more useful.","title":"Reusing UI"},{"location":"tutorials/further-basics/components/#passing-in-children","text":"Sometimes, we want to create components that can hold children. For example, take a look at this component, which arranges some children into a scrolling grid: local function Gallery ( props ) return New \"ScrollingFrame\" { Position = props . Position , Size = props . Size , AnchorPoint = props . AnchorPoint , [ Children ] = { New \"UIGridLayout\" { CellPadding = UDim2 . fromOffset ( 4 , 4 ), CellSize = UDim2 . fromOffset ( 100 , 100 ) }, -- TODO: put some children here? } } end Suppose we'd like users to be able to pass in children to show up in the grid: local gallery = Gallery { Position = UDim2 . fromScale ( .5 , .5 ) Size = UDim2 . fromOffset ( 400 , 300 ), AnchorPoint = Vector2 . new ( .5 , .5 ), [ Children ] = { New \"ImageLabel\" { ... }, New \"ImageLabel\" { ... }, New \"ImageLabel\" { ... } } } We can access those children in our function using props [ Children ] . Since the New function lets us pass in arrays of children, we can just include it directly in our code like so: local function Gallery ( props ) return New \"ScrollingFrame\" { Position = props . Position , Size = props . Size , AnchorPoint = props . AnchorPoint , [ Children ] = { New \"UIGridLayout\" { CellPadding = UDim2 . fromOffset ( 4 , 4 ), CellSize = UDim2 . fromOffset ( 100 , 100 ) }, props [ Children ] } } end That's all there is to it! Just keep in mind that [ Children ] is still a property like any other, so if you're processing the children, it might be good to do some type checking first.","title":"Passing in Children"},{"location":"tutorials/further-basics/components/#multiple-instances","text":"In some specific circumstances, you may want to return more than one instance from a component. You shouldn't return multiple values from a component directly. Because of how Lua works, this can introduce subtle bugs in your code: local function ManyThings ( props ) -- don't do this! -- you should only return one value from a component return New \"TextLabel\" {...}, New \"ImageButton\" {...}, New \"Frame\" {...} end local gui1 = New \"ScreenGui\" { -- this will only parent the TextLabel! [ Children ] = ManyThings {} } local gui2 = New \"ScreenGui\" { [ Children ] = { New \"TextLabel\" {...}, -- this is also broken ManyThings {}, New \"TextLabel\" {...} } } A better way to do this is to return an array of instances. This means you only return a single value - the array. This gets around the subtle bugs that normally occur when dealing with multiple return values. Since [ Children ] supports arrays of children, all our instances are now parented as expected: local function ManyThings ( props ) -- using an array ensures we only return one value return { New \"TextLabel\" {...}, New \"ImageButton\" {...}, New \"Frame\" {...} } end local gui1 = New \"ScreenGui\" { -- this now works! [ Children ] = ManyThings {} } local gui2 = New \"ScreenGui\" { [ Children ] = { New \"TextLabel\" {...}, -- this also now works! ManyThings {}, New \"TextLabel\" {...} } } Tip If you're coming from other UI libraries or frameworks, you may have heard of this concept referred to as 'fragments'. In Fusion, fragments are just plain arrays of children rather than a special kind of object.","title":"Multiple Instances"},{"location":"tutorials/further-basics/components/#callbacks","text":"For some components (e.g. buttons or text boxes), some code might need to run in response to events like clicks or typing. You can use callbacks to achieve this. Consider this Button component as an example. Notice we're using props.OnClick with [ OnEvent \"Activated\" ] : local function Button ( props ) return New \"TextButton\" { Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , BackgroundColor3 = Color3 . new ( 0 , 0.4 , 1 ), TextColor3 = Color3 . new ( 1 , 1 , 1 ), Text = props . Message , [ OnEvent \"Activated\" ] = props . OnClick } end This means that anyone using the Button component can provide a callback function, which will then be run when the button is clicked: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { Button { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Message = \"Click me!\" , OnClick = function () -- this callback function will be passed into OnEvent, so it'll -- run when the button is clicked print ( \"The button was clicked!\" ) end }, } } This isn't just limited to event handlers, either - any time you want to let the caller provide some code, callbacks are a great option.","title":"Callbacks"},{"location":"tutorials/further-basics/components/#state","text":"Because components are functions, we can do more than just creating instances. You can also store state inside them! Let's make a 'toggle button' component to demonstrate this. When we click it, it should toggle on and off. Here's some basic code to get started - we just need to add some state to this: local function ToggleButton ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = props . message , [ OnEvent \"Activated\" ] = function () -- TODO: toggle the button! end } end Firstly, let's create a state object to store whether the button is currently toggled on or off: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () -- TODO: toggle the button! end } end Next, we can toggle the stored value in our event handler: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 1 , 1 , 1 ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () isButtonOn : set ( not isButtonOn : get ()) end } end Finally, we can make the background colour show whether the button is toggled on or off, using some computed state: local function ToggleButton ( props ) local isButtonOn = State ( false ) return New \"TextButton\" { BackgroundColor3 = Computed ( function () if isButtonOn : get () then return Color3 . new ( 0 , 1 , 0 ) -- green when toggled on else return Color3 . new ( 1 , 0 , 0 ) -- red when toggled off end end ), TextColor3 = Color3 . new ( 0 , 0 , 0 ), Text = props . message , [ OnEvent \"Activated\" ] = function () isButtonOn : set ( not isButtonOn : get ()) end } end With just this code, we've made our toggle button fully functional! Again, this is a regular Lua function, so nothing fancy is going on behind the scenes. Just like before, we can now include our toggle button in our UI easily: local gui = New \"ScreenGui\" { Name = \"ExampleGui\" , ZIndexBehavior = \"Sibling\" , [ Children ] = { New \"UIListLayout\" { Padding = UDim . new ( 0 , 4 ) }, ToggleButton { message = \"Click me!\" }, ToggleButton { message = \"Also, click me!\" }, ToggleButton { message = \"Each button is independent :)\" } } } Because we create a new button each time we call the function, each button keeps it's own state and functions independently.","title":"State"},{"location":"tutorials/further-basics/project-2/","text":"Under construction This page is under construction - information may be incomplete or missing.","title":"Project 2: To-Do List"}]}